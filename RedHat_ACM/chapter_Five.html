<!--
title: Chapter_Five ~ Metal
description: 
published: true
date: 2025-10-25T19:27:43.481Z
tags: 
editor: ckeditor
dateCreated: 2025-10-25T10:39:25.587Z
-->

<h3>GitOps Application Model</h3>
<ul>
  <li><strong>ApplicationSet</strong> custom resource represents Argo CD applications that a controller generates.</li>
  <li><strong>Placement: </strong>For cluster targeting</li>
  <li><strong>ClusterSet: </strong>managed clusters group</li>
  <li><strong>GitOpsCluster &nbsp;</strong>custom resource represents an Argo CD server and its associated placement, to help integrating Argo CD with RHACM's cluster management capabilities.</li>
</ul>
<h3>Push and Pull Models</h3>
<ul>
  <li>In the <i>Push</i> model, the Argo CD server, which is running on the hub cluster,<mark class="marker-yellow"> takes direct action</mark> to deploy application resources to the managed clusters.<ul>
      <li>hub cluster must own the necessary credentials to access and interact with the managed clusters.</li>
      <li>The Argo CD application on the hub cluster actively communicates with the Git repository and then directly applies the manifests to the managed clusters</li>
      <li><mark class="marker-yellow">Push model is the default method</mark> for deploying applications unless you use explicit <mark class="marker-yellow">annotations </mark>to enable the Pull model.</li>
    </ul>
  </li>
  <li>Conversely, in the <i>Pull</i> model, the hub cluster <mark class="marker-yellow">propagates the application resources</mark> to the managed clusters by using a <code>ManifestWork</code> object<ul>
      <li>Each managed cluster individually communicates with the Git repository to deploy the resource manifests locally</li>
      <li>Argo CD server must be running on each target managed cluster, which then deploys the replicated application resources locally.</li>
      <li>openshift gitops operator is installed on each &nbsp;managed cluster</li>
    </ul>
  </li>
</ul>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td>Push model</td>
        <td>Pull model</td>
      </tr>
      <tr>
        <td>centralized hub cluster has reliable and direct network connectivity to all remote clusters</td>
        <td>the centralized hub cluster cannot start connections to remote clusters, but the remote clusters can communicate back to the centralized cluster</td>
      </tr>
      <tr>
        <td>a managed cluster cannot reach the Git server directly due to network constraints or security policie</td>
        <td>each managed cluster maintains its own copy of the configuration and independently pulls updates from Git.</td>
      </tr>
      <tr>
        <td><mark class="marker-pink">Deploying applications by using the Push model can potentially overload the OpenShift GitOps controller's memory and CPU usage on the hub cluster</mark></td>
        <td><mark class="marker-green">provides significant scalability relief by offloading the direct deployment workload from the hub cluster's controller</mark></td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>enhance security because you do not need to centrally store sensitive cluster credentials on the hub cluster for direct push operations to every managed cluster, <strong>Decentralization</strong></td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>Reduce the impact of a single point of centralized failure for application delivery</td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>The system excludes the local cluster as a target managed cluster for deployments.</td>
      </tr>
    </tbody>
  </table>
</figure>
<blockquote>
  <p><code>ManifestWork</code> is used to define a group of Kubernetes resources on the hub to be applied to the managed cluster. In the open-cluster-management project, a <code>ManifestWork</code> resource must be created in the cluster namespace. A work agent implemented in <a href="https://github.com/open-cluster-management-io/ocm/tree/main/cmd/work"><u>work</u></a> project is run on the managed cluster and monitors the <code>ManifestWork</code> resource in the cluster namespace on the hub cluster.</p>
</blockquote>
<pre><code class="language-plaintext">apiVersion: work.open-cluster-management.io/v1
kind: ManifestWork
metadata:
  namespace: &lt;target managed cluster&gt;
  name: hello-work-demo
spec:
  workload:
    manifests:
      - apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: hello
          namespace: default
        spec:
          selector:
            matchLabels:
              app: hello
          template:
            metadata:
              labels:
                app: hello
            spec:
              containers:
                - name: hello
                  image: quay.io/asmacdo/busybox
                  command:
                    ["sh", "-c", 'echo "Hello, Kubernetes!" &amp;&amp; sleep 3600']



                    </code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<figure class="image image_resized" style="width:100%;"><img src="/pullmodel.png"></figure>
<p>&nbsp;</p>
<h4><strong>Instillation</strong></h4>
<p><strong>âˆ… RHACM operator does not include Argo CD. Instead, you must install Argo CD by deploying the OpenShift GitOps operator.</strong></p>
<ul>
  <li>OpenShift GitOps operator:<ul>
      <li>&nbsp;manages Argo CD instances in OpenShift clusters.</li>
      <li>creates a default Argo CD instance in the <code>openshift-gitops</code> namespace.</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>In Argo CD, an <i>application</i> is a resource that references a Git repository with Kubernetes resource definitions.</p>
</blockquote>
<ul>
  <li>In the pull mode the operator must be installed on each managed cluster unlike in the push mode</li>
</ul>
<h3>Configuration</h3>
<ul>
  <li>Grant the OpenShift administrators access to the Argo CD web console.<ul>
      <li>OpenShift manages the Argo CD instances by using <code>ArgoCD</code> resources.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">---
apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
spec:
  ...output omitted...
  rbac:
    defaultPolicy: ""
    policy: |
      g, system:cluster-admins, role:admin   &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the kube-admin user
      g, cluster-admins, role:admin          &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anyone in the cluster-admins group
      g, ocpadmins, role:admin
    scopes: '[groups]'
...output omitted...</code></pre>
<ul>
  <li>Grant the Argo CD instance the required permissions to deploy applications.<ul>
      <li>must grant the <code>cluster-admin</code> permissions to <code>openshift-gitops-argocd-application-controller</code> service account in addition to the default permissions.</li>
    </ul>
  </li>
  <li>Install your custom certificate authority (CA) certificates into the Argo CD instance so that Argo CD can pull Git repositories from private Git systems.<ul>
      <li>Add the private CA certificate to a configuration map in the <code>openshift-gitops</code> namespace. or create a configuration map with the <code>config.openshift.io/inject-trusted-cabundle</code> label. When this label is set, OpenShift automatically populates the configuration map with the cluster CA bundle.</li>
      <li>Mount the configuration map as a volume inside the Argo CD instance.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
  ...output omitted...
spec:
  ...output omitted...
  repo:
    volumeMounts:
      - mountPath:
          /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
        subPath: ca-bundle.crt
        name: cluster-root-ca-bundle
    volumes:
      - configMap:
          name: cluster-root-ca-bundle
        name: cluster-root-ca-bundle
...output omitted...</code></pre>
<h3>Importing Managed Clusters into Argo CD</h3>
<ul>
  <li>register the managed clusters with Argo CD by creating a <code>GitOpsCluster</code> resource:</li>
</ul>
<pre><code class="language-plaintext">---
apiVersion: apps.open-cluster-management.io/v1beta1
kind: GitOpsCluster
metadata:
  name: gitops-clusters
  namespace: openshift-gitops
spec:
  argoServer:  
    argoNamespace: openshift-gitops
  placementRef:  
    kind: Placement
    apiVersion: cluster.open-cluster-management.io/v1beta1
    name: clusters-for-gitops
    namespace: openshift-gitops</code></pre>
<h3>Deploying applications</h3>
<ul>
  <li>ArgoCD supports deploying resources from Git repos with many content types:<ol>
      <li>Kustomize:&nbsp;<ul>
          <li>Argo CD automatically detects the Kustomize structure of the application in the Git repository, and uses Kustomize to deploy the application.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>
<blockquote>
  <p>Each configuration set needs a <code>kustomization.yaml</code> file. The <code>kustomization.yaml</code> files define how the settings in the overlay interact with the base YAML files to build new manifests. The new manifest builds are called <i>variants</i>, and consist of the base YAML files and their overlays.</p>
</blockquote>
<pre><code class="language-plaintext">--- &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; base directory
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - deployment.yaml
  - route.yaml
  - service.yaml</code></pre>
<pre><code class="language-plaintext">--- &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; overlay dir
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../base
  - pvc.yaml

patches:
  - patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: myapp
      spec:
        replicas: 3</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
