<!--
title: Chapter_Five ~ Metal
description: 
published: true
date: 2025-11-04T18:16:06.250Z
tags: 
editor: ckeditor
dateCreated: 2025-10-20T18:35:38.377Z
-->

<h3>GitOps Application Model</h3>
<ul>
  <li><strong>ApplicationSet</strong> custom resource represents Argo CD application resource that a controller generates.</li>
  <li><strong>Placement: </strong>For cluster targeting</li>
  <li><strong>ClusterSet: </strong>managed clusters group</li>
  <li><strong>GitOpsCluster &nbsp;</strong>custom resource represents an Argo CD server and its associated placement, to help integrating Argo CD with RHACM's cluster management capabilities.</li>
</ul>
<h3>Push and Pull Models</h3>
<ul>
  <li>In the <i>Push</i> model, the Argo CD server, which is running on the hub cluster,<mark class="marker-yellow"> takes direct action</mark> to deploy application resources to the managed clusters.<ul>
      <li>hub cluster must own the necessary credentials to access and interact with the managed clusters.</li>
      <li>The Argo CD application on the hub cluster actively communicates with the Git repository and then directly applies the manifests to the managed clusters</li>
      <li><mark class="marker-yellow">Push model is the default method</mark> for deploying applications unless you use explicit <mark class="marker-yellow">annotations </mark>to enable the Pull model.</li>
    </ul>
  </li>
  <li>Conversely, in the <i>Pull</i> model, the hub cluster <mark class="marker-yellow">propagates the application resources</mark> to the managed clusters by using a <code>ManifestWork</code> object<ul>
      <li>Each managed cluster individually communicates with the Git repository to deploy the resource manifests locally</li>
      <li>Argo CD server must be running on each target managed cluster, which then deploys the replicated application resources locally.</li>
      <li>openshift gitops operator is installed on each &nbsp;managed cluster</li>
    </ul>
  </li>
</ul>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td>Push model</td>
        <td>Pull model</td>
      </tr>
      <tr>
        <td>centralized hub cluster has reliable and direct network connectivity to all remote clusters</td>
        <td>the centralized hub cluster cannot start connections to remote clusters, but the remote clusters can communicate back to the centralized cluster</td>
      </tr>
      <tr>
        <td>a managed cluster cannot reach the Git server directly due to network constraints or security policie</td>
        <td>each managed cluster maintains its own copy of the configuration and independently pulls updates from Git.</td>
      </tr>
      <tr>
        <td><mark class="marker-pink">Deploying applications by using the Push model can potentially overload the OpenShift GitOps controller's memory and CPU usage on the hub cluster</mark></td>
        <td><mark class="marker-green">provides significant scalability relief by offloading the direct deployment workload from the hub cluster's controller</mark></td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>enhance security because you do not need to centrally store sensitive cluster credentials on the hub cluster for direct push operations to every managed cluster, <strong>Decentralization</strong></td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>Reduce the impact of a single point of centralized failure for application delivery</td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>The system excludes the local cluster as a target managed cluster for deployments.</td>
      </tr>
    </tbody>
  </table>
</figure>
<blockquote>
  <p><code>ManifestWork</code> is used to define a group of Kubernetes resources on the hub to be applied to the managed cluster. In the open-cluster-management project, a <code>ManifestWork</code> resource must be created in the cluster namespace. A work agent implemented in <a href="https://github.com/open-cluster-management-io/ocm/tree/main/cmd/work"><u>work</u></a> project is run on the managed cluster and monitors the <code>ManifestWork</code> resource in the cluster namespace on the hub cluster.</p>
</blockquote>
<pre><code class="language-plaintext">apiVersion: work.open-cluster-management.io/v1
kind: ManifestWork
metadata:
  namespace: &lt;target managed cluster&gt;
  name: hello-work-demo
spec:
  workload:
    manifests:
      - apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: hello
          namespace: default
        spec:
          selector:
            matchLabels:
              app: hello
          template:
            metadata:
              labels:
                app: hello
            spec:
              containers:
                - name: hello
                  image: quay.io/asmacdo/busybox
                  command:
                    ["sh", "-c", 'echo "Hello, Kubernetes!" &amp;&amp; sleep 3600']



                    </code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<figure class="image image_resized" style="width:100%;"><img src="/pullmodel.png"></figure>
<p>&nbsp;</p>
<h4><strong>Instillation</strong></h4>
<p><strong>âˆ… RHACM operator does not include Argo CD. Instead, you must install Argo CD by deploying the OpenShift GitOps operator.</strong></p>
<ul>
  <li>OpenShift GitOps operator:<ul>
      <li>manages Argo CD instances in OpenShift clusters.</li>
      <li>creates a default Argo CD instance in the <code>openshift-gitops</code> namespace.</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>In Argo CD, an <i>application</i> is a resource that references a Git repository with Kubernetes resource definitions.</p>
</blockquote>
<ul>
  <li>In the pull mode the operator must be installed on each managed cluster unlike in the push mode</li>
</ul>
<h3>Configuration</h3>
<ul>
  <li>Grant the OpenShift administrators access to the Argo CD web console.<ul>
      <li>OpenShift manages the Argo CD instances by using <code>ArgoCD</code> resources.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">---
apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
spec:
  ...output omitted...
  rbac:
    defaultPolicy: ""
    policy: |
      g, system:cluster-admins, role:admin   &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the kube-admin user
      g, cluster-admins, role:admin          &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anyone in the cluster-admins group
      g, ocpadmins, role:admin
    scopes: '[groups]'
...output omitted...</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Grant the Argo CD instance the required permissions to deploy applications.<ul>
      <li>must grant the <code>cluster-admin</code> permissions to <code>openshift-gitops-argocd-application-controller</code> service account in addition to the default permissions.</li>
    </ul>
  </li>
  <li>Install your custom certificate authority (CA) certificates into the Argo CD instance so that Argo CD can pull Git repositories from private Git systems.<ul>
      <li>Add the private CA certificate to a configuration map in the <code>openshift-gitops</code> namespace. or create a configuration map with the <code>config.openshift.io/inject-trusted-cabundle</code> label. When this label is set, OpenShift automatically populates the configuration map with the cluster CA bundle.</li>
      <li>Mount the configuration map as a volume inside the Argo CD instance.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
  ...output omitted...
spec:
  ...output omitted...
  repo:
    volumeMounts:
      - mountPath:
          /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
        subPath: ca-bundle.crt
        name: cluster-root-ca-bundle
    volumes:
      - configMap:
          name: cluster-root-ca-bundle
        name: cluster-root-ca-bundle
...output omitted...</code></pre>
<h3>Importing Managed Clusters into Argo CD</h3>
<ul>
  <li>register the managed clusters with Argo CD by creating a <code>GitOpsCluster</code> resource:</li>
</ul>
<pre><code class="language-plaintext">---
apiVersion: apps.open-cluster-management.io/v1beta1
kind: GitOpsCluster
metadata:
  name: gitops-clusters
  namespace: openshift-gitops
spec:
  argoServer:  
    argoNamespace: openshift-gitops
  placementRef:  
    kind: Placement
    apiVersion: cluster.open-cluster-management.io/v1beta1
    name: clusters-for-gitops
    namespace: openshift-gitops</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>Deploying Applications</h3>
<ul>
  <li>ArgoCD fetches the manifests files for application resources from Git repos and supports many content types:<ol>
      <li>Kustomize:</li>
    </ol>
  </li>
</ul>
<blockquote>
  <p>Argo CD automatically detects the Kustomize structure of the application in the Git repository, and uses Kustomize to deploy the application.</p>
</blockquote>
<p>&nbsp; &nbsp; &nbsp;2. Helm charts</p>
<p>&nbsp; &nbsp; &nbsp;3. directories&nbsp;</p>
<h3>Application management</h3>
<ol>
  <li>ApplicationSet: acts as a template that Argo CD uses to create an <code>Application</code> resource for each cluster.<ul>
      <li>Argo CD generates the <code>Application</code> resources in the <code>openshift-gitops</code> namespace</li>
    </ul>
  </li>
</ol>
<pre><code class="language-plaintext">---
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: myapp
  namespace: openshift-gitops
spec:
  generators:
    - clusterDecisionResource:
        configMapRef: acm-placement
        labelSelector:
          matchLabels:
            cluster.open-cluster-management.io/placement: myapp-placement  
        requeueAfterSeconds: 180
  template:  
    metadata:
      labels:
        velero.io/exclude-from-backup: "true"
      name: myapp-{{name}}  
    spec:
      destination:
        namespace: myapp
        server: '{{server}}'  
      project: default
      sources:  
        - path: kustomize/overlays/production
          repoURL: https://github.com/myorganization/myapp.git
          targetRevision: main
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
        syncOptions:
          - CreateNamespace=true
          - PruneLast=true</code></pre>
<p>&nbsp;</p>
<p>2. A <code>Placement</code> resource: selects clusters form a cluster set.</p>
<pre><code class="language-plaintext">---
apiVersion: cluster.open-cluster-management.io/v1beta1
kind: Placement
metadata:
  name: myapp-placement
  namespace: openshift-gitops
spec:
  clusterSets:  
    - my-openshift-clusters
  numberOfClusters: 3 
  predicates:  
    - requiredClusterSelector:
        labelSelector:
          matchLabels:
            openshiftVersion: 4.18.6</code></pre>
<h4>Deploying an Application by Using the Pull Model</h4>
<ul>
  <li>install the Red&nbsp;Hat OpenShift GitOps operator in each managed cluster</li>
  <li>You cannot deploy applications on the hub cluster. Your <code>Placement</code> resource must exclude this cluster.</li>
</ul>
<pre><code class="language-plaintext">---
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: myapp-pull
  namespace: openshift-gitops
spec:
  generators:
    - clusterDecisionResource:
        configMapRef: acm-placement
        labelSelector:
          matchLabels:
            cluster.open-cluster-management.io/placement: myapp-pull-placement
        requeueAfterSeconds: 180
  template:
    metadata:
      annotations:
        apps.open-cluster-management.io/ocm-managed-cluster: '{{name}}'
        apps.open-cluster-management.io/ocm-managed-cluster-app-namespace:
          openshift-gitops
        argocd.argoproj.io/skip-reconcile: "true"
      labels:
        apps.open-cluster-management.io/pull-to-ocm-managed-cluster: "true"
        velero.io/exclude-from-backup: "true"
      name: myapp-pull-{{name}}
    spec:
      destination:
        namespace: myapp-pull
        server: '{{server}}'
      project: default
      sources:
        - path: kustomize/overlays/production
          repoURL: https://github.com/myorganization/myapp.git
          targetRevision: main
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
        syncOptions:
          - CreateNamespace=true
          - PruneLast=true</code></pre>
<ol>
  <li>The Argo CD instance that is running in the hub cluster processes the <code>ApplicationSet</code> resource and creates the corresponding <code>Application</code> resources.</li>
  <li>The <code>argocd.argoproj.io/skip-reconcile="true"</code> annotation instructs Argo CD not to process the <code>Application</code> resources further.</li>
  <li>RHACM detects the new <code>Application</code> resources with the <code>apps.open-cluster-management.io/pull-to-ocm-managed-cluster="true"</code> label.</li>
  <li>RHACM creates <code>ManifestWork</code> resources in the namespaces of the managed clusters.</li>
  <li>RHACM uses the <code>apps.open-cluster-management.io/ocm-managed-cluster</code> and <code>apps.open-cluster-management.io/ocm-managed-cluster-app-namespace</code> annotations to create these resources. A <code>ManifestWork</code> resource embeds the <code>Application</code> resource definition for the cluster.</li>
  <li>The managed cluster retrieves and processes the <code>ManifestWork</code> resource from the hub cluster. The managed cluster creates the <code>Application</code> resource.</li>
  <li>The Argo CD instance that is running in the managed cluster detects and processes the <code>Application</code> resource, which deploys the application.</li>
  <li>The RHACM hub cluster collects the status of the application by creating a <code>MulticlusterApplicationSetReport</code> resource.</li>
  <li>The topology view uses the <code>MulticlusterApplicationSetReport</code> resource for displaying the application status.</li>
</ol>
<h4>Deleting Applications</h4>
<pre><code class="language-plaintext"> oc delete ApplicationSet myapp -n openshift-gitops
 oc delete placement myapp-placement -n openshift-gitops</code></pre>
<p>&nbsp;</p>
