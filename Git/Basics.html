<!--
title: Git Basics
description: 
published: true
date: 2026-01-14T20:35:08.233Z
tags: 
editor: ckeditor
dateCreated: 2026-01-12T17:31:57.809Z
-->

<h1>What is Git</h1>
<blockquote>
  <p>it is a very simple beast, Git is at it’s heart very stupid simple</p>
</blockquote>
<ul>
  <li>Distributed version control system<ul>
      <li>Distributed: local and remote repos</li>
      <li>Version Control: go back in time without changing the changes</li>
      <li>track the changes and who made them and when</li>
    </ul>
  </li>
  <li>Local repo stages<ul>
      <li>working area</li>
      <li>staging area files are tracked starting from here</li>
      <li>committed files</li>
    </ul>
  </li>
</ul>
<h3>Commnads</h3>
<ul>
  <li>to add an email and username for the repos</li>
</ul>
<pre><code class="language-plaintext">git config user.name &lt;name&gt; or user.email &lt;email&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to initialize a new repo</li>
</ul>
<pre><code class="language-plaintext">git init</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to see the status of the files in the git repo</li>
</ul>
<pre><code class="language-plaintext">git status</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">$ git status
On branch master  &gt;&gt; the current branch

No commits yet

Untracked files: &gt;&gt; in the working area
  (use "git add &lt;file&gt;..." to include in what will be committed)
        test.txt &gt;&gt; to add the file to the staginging area

nothing added to commit but untracked files present (use "git add" to track)</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to add files to the staging area</li>
</ul>
<blockquote>
  <p>In the staging area we can add files individually and commit them. For example, if we have file 1 and file2, and we finished working on file2 gist add the file 2 to the staging area and commit without file 1&nbsp;</p>
</blockquote>
<pre><code class="language-plaintext">git add &lt;files&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to commit files from the staging area</li>
</ul>
<blockquote>
  <p>commit should be atomic, meaning that the should fix one issue or introduce one feature</p>
</blockquote>
<pre><code class="language-plaintext">git commit -m "message"</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>&nbsp;A commit records the change in the repository compared to its previous state.</p>
</blockquote>
<ul>
  <li>to restore a file from the staged area</li>
</ul>
<pre><code class="language-plaintext">git restore --staged &lt;file&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to discard changes in the working area and return to the state in the staging state</li>
</ul>
<pre><code class="language-plaintext">git restore &lt;file&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to remove one tracked files form the repo commits</li>
</ul>
<pre><code class="language-plaintext">git rm --force &gt; delete the file forever or --cached &gt; retain the file in the working dir &lt;file&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>.gitignore file to ignore local files while staging</li>
  <li>to see the commit history</li>
</ul>
<pre><code class="language-plaintext">git log | --one-line for compact view</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">commit 0aa6189134d19b3ea45347c177b0c2d531ddfe62 &gt;&gt; hash
Author: Ibrahim Mohamed &lt;sci.ibrahimmohamed@gmail.com&gt; &gt;&gt; info
Date:   Mon Jan 12 19:46:14 2026 +0200

    first &gt;&gt; commit message
</code></pre>
<ul>
  <li>to &nbsp;list the changed files</li>
</ul>
<pre><code class="language-plaintext">git log --name-only</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">commit 3004087b51e96b08d67bc05c73bc36cc9d76a8f3 (HEAD -&gt; master)
Author: sarah &lt;sarah@example.com&gt;
Date:   Mon Jan 12 18:39:47 2026 +0000

    Added the lion and mouse story

lion-and-mouse.txt</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to get the latest commit</li>
</ul>
<pre><code class="language-cs">git log -n 1</code></pre>
<h3>Branches&nbsp;</h3>
<ul>
  <li>default branch is master</li>
  <li>a branch is a pointer to a specific &nbsp;commit</li>
  <li>to create a new branch</li>
</ul>
<pre><code class="language-plaintext">git checkout -b &lt;branch name&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to list all the branches</li>
</ul>
<pre><code class="language-plaintext">git branch</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to switch to another branch</li>
</ul>
<pre><code class="language-plaintext">git checkout &lt;branch name&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to delete a branch</li>
</ul>
<pre><code class="language-plaintext">git branch -d &lt; name &gt;.</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>Head point to the last commit on the current branch</p>
</blockquote>
<ul>
  <li>to merge branches first switch to the base branch and</li>
</ul>
<pre><code class="language-plaintext">git merge &lt;overlay_branch&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>types of merge:<ul>
      <li>fast forward: if the base branch has no extra commits, the head of the base branch is just moved to the last commit of the overlay branch</li>
      <li>no &nbsp;fast forward: if the base branch has extra commits, git creates a new merging commit on the base branch that points to both branches</li>
    </ul>
  </li>
</ul>
<h3>Remote repos</h3>
<ul>
  <li>connect to the remote repos by using connection strings https://../…/name.git</li>
</ul>
<pre><code class="language-plaintext">git remote add &lt;alias&gt; &lt;connection string&gt; </code></pre>
<ul>
  <li>this command adds the remote repo and give it an alias &lt;origin&gt; that will be used in other steps</li>
  <li>to list all the remote repos</li>
</ul>
<pre><code class="language-plaintext">git remote -v</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to push data to the remote repo</li>
</ul>
<pre><code class="language-plaintext">git push &lt;alias&gt; &lt;current branch&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to clone a repo</li>
</ul>
<pre><code class="language-plaintext">git clone [connection string]</code></pre>
<h3>Pull Request&nbsp;</h3>
<ul>
  <li>a request to add the changes to the main &nbsp;branch</li>
  <li>to fetch the latest changes</li>
</ul>
<pre><code class="language-plaintext">git fetch &lt;alias&gt; &lt;branch&gt;</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>&nbsp; &nbsp;the remote branches are saved under remotes/alias/branch till be merged</p>
</blockquote>
<pre><code class="language-plaintext">git merge alias/branch &gt; to merge the remote changes to the local branch</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to check the logs of the remote branch</li>
</ul>
<pre><code class="language-plaintext">git log alias/branch</code></pre>
<p>&nbsp;</p>
<ul>
  <li>to compline the two steps</li>
</ul>
<pre><code class="language-plaintext">git pull alias/branch</code></pre>
<p>&nbsp;</p>
<ul>
  <li>merge conflicts<ul>
      <li>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD shows the current content of the conflicting files</li>
      <li>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; User shows the content that should be merged</li>
      <li>Modify the conflicting files and stage them to be committed again to resolve the merge conflict</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p><strong>differences on the same file do </strong><i><strong>not</strong></i><strong> raise a merge conflict in Git.</strong><br>&nbsp; They are considered <strong>compatible changes</strong> and Git will auto-merge them.</p>
</blockquote>
<pre><code class="language-plaintext">Auto-merge case (no conflict)
Example

Base

1: int a = 1;
2: int b = 2;
3: int c = 3;


Branch A

1: int a = 10;   // changed
2: int b = 2;
3: int c = 3;


Branch B

1: int a = 1;
2: int b = 2;
3: int c = 30;   // changed


Result after merge:

1: int a = 10;
2: int b = 2;
3: int c = 30;</code></pre>
<h6>Forks</h6>
<ul>
  <li>Another copy of the codebase that does not affect the main &nbsp;codebase</li>
  <li>Request a pull request to add the changes from you own copy to the main codebase</li>
</ul>
<h6>Rebasing</h6>
<ul>
  <li>Putting one branch on top of another one:<ul>
      <li>creates new commits automatically with new hashes because the commits are copied from one branch to another</li>
      <li>modifies the git history by the interactive rebase</li>
      <li><code>git rebase -i HEAD~x&nbsp;</code>
        <ul>
          <li>x number of commit that should be modified</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">git switch destination branch
git rebase target branch</code></pre>
<h3>Cherry Picking</h3>
<ul>
  <li>picking only one commit for a different branch</li>
</ul>
<pre><code class="language-plaintext">git cherry-pick &lt;hash&gt;</code></pre>
<h3>Reverting and Resetting &nbsp;</h3>
<ul>
  <li>git revert command creates a new commit that contain everything expect the things in the reverted commit and delete the changes in that commit</li>
</ul>
<pre><code class="language-plaintext">git revert &lt;commit to be reverted&gt; or HEAD~0</code></pre>
<ul>
  <li>git reset soft or hard to keep or lose the changes in the working area</li>
</ul>
<pre><code class="language-plaintext">git reset --sort | --hard HEAD~x</code></pre>
<ul>
  <li>--soft removes the changes from the commit and keeps them in the working area</li>
  <li>--hard drop the changes completely&nbsp;</li>
</ul>
<h3>stashing</h3>
<ul>
  <li>git stash&nbsp;</li>
  <li>git stash list</li>
  <li>git stash show &lt;name&gt;</li>
  <li>git stash pop &nbsp;&lt;name&gt;</li>
</ul>
<h3>RefLog</h3>
<ul>
  <li>shows all the actions done on the repo and can undo any action (even --hard reset) by changing &nbsp;the head position to a commit</li>
</ul>
<h3>How Git really works?</h3>
<ul>
  <li>Git is a content-addressable object database and its units are trees, commits, and blobs.</li>
  <li>Combining commits together for &nbsp;a DAG</li>
</ul>
<blockquote>
  <p>DAG: because commit point backward to their parents and in a &nbsp;non cyclic way</p>
</blockquote>
<ul>
  <li>objects in the object database<ul>
      <li>commit is a complete snapshot of entire project at a point of time and contain:<ul>
          <li>A pointer to the complete snapshot ( THE ROOT TREE !!)</li>
          <li>Metadata about the commit</li>
          <li>Pointer to the parent commit except the first commit that has no parent</li>
        </ul>
      </li>
      <li>Trees: Pointers to file names, blobs(content), other trees</li>
      <li>Blobs: the actual compressed data, only the file content no thing else</li>
    </ul>
  </li>
  <li>Tags and branches<ul>
      <li>Pointers to commits to give these commits a name and other metadata</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>Every object of this database is stored in the desk on .git/objects/SHA 1 of the file content &nbsp;and the content is ZIP encrypted</p>
</blockquote>
<pre><code class="language-plaintext">git cat-file -t &lt;type&gt; or -p &lt;content&gt; SHA</code></pre>
<h3>Actual Demo</h3>
<ul>
  <li>Once a git repo is initialized these dirs &nbsp;are created</li>
</ul>
<pre><code class="language-plaintext">Every 1.0s: find .                                    k8s-master: Tue Jan 13 22:04:22 2026

.
./.git
./.git/branches
./.git/hooks
./.git/info
./.git/info/exclude
./.git/description
./.git/config
./.git/refs
./.git/refs/heads
./.git/refs/tags
./.git/HEAD

./.git/index

......
</code></pre>
<ul>
  <li>after adding a file to the staging area</li>
</ul>
<pre><code class="language-plaintext">Every 1.0s: find .                                    k8s-master: Tue Jan 13 22:05:16 2026

.
./.git
./.git/branches
./.git/hooks
./.git/info
./.git/info/exclude
./.git/description
./.git/config
./.git/refs
./.git/refs/heads
./.git/refs/tags
./.git/HEAD
./.git/objects
./.git/objects/pack
./.git/objects/info
./.git/objects/d6
./.git/objects/d6/c6a3b586af9530f6235f804d3fbbf3246a4756 &gt;&gt; a blob with the content of the file
./.git/index                                             &gt;&gt; contain the name of the files temporairly untill the next commit 
./test1.txt
</code></pre>
<pre><code class="language-plaintext">[root@k8s-master git]# git cat-file -t d6c6
blob
[root@k8s-master git]# git cat-file -p d6c6
this is a test
to test that
more than on line
in different blobs
s
</code></pre>
<ul>
  <li>after the first commit</li>
</ul>
<pre><code class="language-plaintext">Every 1.0s: find .                                                          k8s-master: Tue Jan 13 22:07:30 2026

.
./.git
./.git/branches
./.git/hooks
./.git/info
./.git/info/exclude
./.git/description
./.git/config
./.git/refs
./.git/refs/heads
./.git/refs/heads/master
./.git/refs/tags
./.git/HEAD
./.git/objects
./.git/objects/pack
./.git/objects/info
./.git/objects/d6
./.git/objects/d6/c6a3b586af9530f6235f804d3fbbf3246a4756  &gt;&gt; the blob 
./.git/objects/62
./.git/objects/62/0e8c4c4fd1a7f859c4261bb81509f3964c34e3  &gt;&gt; the root tree
./.git/objects/6e
./.git/objects/6e/e1ee55207b4c0f8d43faf8e425536822cfabb0  &gt;&gt; a commit
./.git/index
./.git/COMMIT_EDITMSG
./.git/logs
./.git/logs/HEAD
./.git/logs/refs
./.git/logs/refs/heads
./.git/logs/refs/heads/master
./test1.txt
</code></pre>
<pre><code class="language-plaintext">[root@k8s-master git]# git cat-file -t 620e
tree
[root@k8s-master git]# git cat-file -p 620e
100644 blob d6c6a3b586af9530f6235f804d3fbbf3246a4756    test1.txt</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">[root@k8s-master git]# git cat-file -t 6ee1
commit
[root@k8s-master git]# git cat-file -p 6ee1
tree 620e8c4c4fd1a7f859c4261bb81509f3964c34e3
author Your Name &lt;you@example.com&gt; 1768334837 +0200
committer Your Name &lt;you@example.com&gt; 1768334837 +0200

first
</code></pre>
<ul>
  <li>committing another file creates two more objects a tree and a commit<ul>
      <li>the tree contains the two blobs the old and the new one</li>
      <li>the new commit reference the new tree that contain the new blob</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">Every 1.0s: find .                                    k8s-master: Tue Jan 13 22:22:38 2026

.
./.git
./.git/branches
./.git/hooks
./.git/info
./.git/info/exclude
./.git/description
./.git/config
./.git/refs
./.git/refs/heads
./.git/refs/heads/master
./.git/refs/tags
./.git/HEAD
./.git/objects
./.git/objects/pack
./.git/objects/info
./.git/objects/d6
./.git/objects/d6/c6a3b586af9530f6235f804d3fbbf3246a4756
./.git/objects/62
./.git/objects/62/0e8c4c4fd1a7f859c4261bb81509f3964c34e3
./.git/objects/6e
./.git/objects/6e/e1ee55207b4c0f8d43faf8e425536822cfabb0
./.git/objects/b1
./.git/objects/b1/0b7f506db51c41ac0eeb008559e2a6ec9a7cc5  &gt;&gt; the new blob for test2.txt content
./.git/objects/34
./.git/objects/34/f0c6c46f6338b4c4ac7103888ca334799bd0b5  &gt;&gt; new tree with the two blobs
./.git/objects/a3
./.git/objects/a3/f622863b944e3fdd212b2039a0786c2864041e  &gt;&gt; the new commit 
./.git/index
./.git/COMMIT_EDITMSG
./.git/logs
./.git/logs/HEAD
./.git/logs/refs
./.git/logs/refs/heads
./.git/logs/refs/heads/master
./test1.txt
./test2.txt
</code></pre>
<pre><code class="language-plaintext">[root@k8s-master git]# git cat-file -t 34f0
tree
[root@k8s-master git]# ls
test1.txt  test2.txt
[root@k8s-master git]# git cat-file -t a3f6
commit
[root@k8s-master git]# git cat-file -p 34f0
100644 blob d6c6a3b586af9530f6235f804d3fbbf3246a4756    test1.txt
100644 blob b10b7f506db51c41ac0eeb008559e2a6ec9a7cc5    test2.txt
[root@k8s-master git]# git cat-file -p a3f6
tree 34f0c6c46f6338b4c4ac7103888ca334799bd0b5
parent 6ee1ee55207b4c0f8d43faf8e425536822cfabb0
author Your Name &lt;you@example.com&gt; 1768335578 +0200
committer Your Name &lt;you@example.com&gt; 1768335578 +0200

second
[root@k8s-master git]#
</code></pre>
<blockquote>
  <p>blobs under the .git/objects are loose files not packfiles so every blob contains the full file content in that commit</p>
  <p>changing the file permissions and content will be considered modification&nbsp;</p>
</blockquote>
<pre><code class="language-plaintext">When Git does use packfiles automatically

	You usually do not need to run git gc manually.

	Git automatically packs objects when:

	You run git fetch or git pull

	You run git push

	Loose object count crosses a threshold

	Background maintenance is enabled (modern Git)</code></pre>
<p>&nbsp;</p>
<ul>
  <li>creating a branch</li>
</ul>
<pre><code class="language-plaintext">./.git/refs
./.git/refs/heads
./.git/refs/heads/master &gt; the head of the master branch pointing to the current commit
./.git/refs/heads/test  &gt; the head of the new branch pointing to the current commit 
./.git/refs/tags</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">[root@k8s-master git]# git branch test
[root@k8s-master git]# cat .git/refs/heads/master
f6271d285780cd056ddb5ef46f7358080d8c9ea3
[root@k8s-master git]# cat .git/refs/heads/test
f6271d285780cd056ddb5ef46f7358080d8c9ea3</code></pre>
<h3>What is rebasing?</h3>
<ul>
  <li>Rebasing creates <i>entirely new commit objects</i> with different SHA-1 hashes, even though the changes (diffs) might be identical.</li>
  <li>A commit's SHA-1 hash is calculated from:<ul>
      <li>The tree it points to (your project snapshot)</li>
      <li>The parent commit(s)</li>
      <li>Author info and timestamp</li>
      <li>Commit message</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>When you rebase, you're changing the <strong>parent commit</strong>, which means you get a completely different SHA-1 hash, which means it's a <strong>new commit object</strong> entirely.</p>
</blockquote>
<h3>How rebasing actually works?</h3>
<ul>
  <li>First we checkout to the feature branch</li>
  <li>when the git rebase master branches Git does these serious of tasks:<ul>
      <li>Git Moves the head of the feature branch to the last commit in the master branch so the feature branch becomes headless temporarily</li>
      <li>Git gets identifies the first common commit between the two branches</li>
      <li>Git identifies the commits in the feature branch that will be replayed</li>
      <li>Git get the diff between the first commit in the feature branch and the common commit between the two branches</li>
      <li>Git takes the tree of the last commit in the master branch and applies the changes that has been found to it, then use it to create a new commit that has the last commit in the master branch as its parent and uses the new created tree<ul>
          <li>the tree is modified with blobs according to the if there is no changes, compatible changes, conflicts between the</li>
          <li>No changes: the tree just uses &nbsp;blobs that in the first commit in the branch, which contains the changes already</li>
          <li>Compatible changes: git auto merge them and create new blob that is used in the new tree</li>
          <li>Conflict: rebase stops till resolving the conflict then creates new blob</li>
        </ul>
      </li>
      <li>Git replays the other commits in the same way</li>
      <li>Git set the last replayed commit as the head of the branch</li>
      <li>The old commits still exist but orphaned and are kept in the RefLog for 30 days by default</li>
    </ul>
  </li>
</ul>
