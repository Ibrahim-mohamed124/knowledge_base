<!--
title: Argocd Configs
description: 
published: true
date: 2026-01-02T17:57:06.017Z
tags: 
editor: ckeditor
dateCreated: 2025-12-30T13:45:21.307Z
-->

<h3>Reconciliation loop &nbsp;</h3>
<ul>
  <li>Reconciliation loop is how often does argocd sync with the git server &gt; by default every 2 min, and can be configured via <code>argocd-cm</code> configmap</li>
  <li>server.insecure: “true” to make the argocd server run in insecure mode</li>
</ul>
<pre><code class="language-plaintext">kubectl -n argocd patch configmap argocd-cm --patch='{"data":{"timeout.reconciliation":"300s"}}'
kubectl -n argocd rollout restart deploy argocd-repo-server</code></pre>
<h6>&nbsp;Webbooks configurations&nbsp;</h6>
<ul>
  <li>Configuring the git server to sent evets to the argocd server by http://IP/api/webhook for the insecure mode</li>
</ul>
<h3>Application Health&nbsp;</h3>
<ul>
  <li>Healthy: all the resources are healthy</li>
  <li>Progressing: Resource is unhealthy but needs time</li>
  <li>Degraded: Resource is unhealthy</li>
  <li>Missing: Resource is not present in the cluster</li>
  <li>Suspended: The resource deployment is paused or suspended.</li>
  <li>Unknown: No data</li>
</ul>
<blockquote>
  <p>The health checks use the status section of the resource to determine if that resource is healthy&nbsp;</p>
</blockquote>
<ul>
  <li>Argocd support custom health checks that are written in LUA language scripts that are defined in the argocd-cm configmap</li>
</ul>
<pre><code class="language-plaintext">data:
  resource.customizations.health.group(do not exist for core"."kind": |
    hs = {}
    if obj.status ~= nil then
      if obj.status.conditions ~= nil then
        for i, condition in ipairs(obj.status.conditions) do
          if condition.type == "Ready" and condition.status == "False" then
            hs.status = "Degraded"
            hs.message = condition.message
            return hs
          end
          if condition.type == "Ready" and condition.status == "True" then
            hs.status = "Healthy"
            hs.message = condition.message
            return hs
          end
        end
      end
    end

    hs.status = "Progressing"
    hs.message = "Waiting for certificate"
    return hs</code></pre>
<h3>Sync strategies</h3>
<ul>
  <li>Manual or Automatic</li>
  <li>Auto-pruning of resources: Auto-pruning feature describes what happens when files are deleted or removed from Git</li>
  <li>self-healing from actual state to the desired state to revert imperative changes in the cluster</li>
</ul>
<h3>Declarative setup of argocd components&nbsp;</h3>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: sample-app
  namespace: argocd   # Namespace where Argo CD is installed
spec:
  project: default

  source:
    repoURL: https://github.com/your-org/your-repo.git
    targetRevision: main
    path: manifests   # Directory containing Kubernetes manifests

  destination:
    server: https://kubernetes.default.svc
    namespace: sample-app

  syncPolicy:
    automated:
      prune: true        # Delete resources removed from Git
      selfHeal: true     # Revert out-of-band changes
    syncOptions:
      - CreateNamespace=true
      - ApplyOutOfSyncOnly=true
  revisionHistoryLimit: 5</code></pre>
<h3>Apps of Apps</h3>
<ul>
  <li>Root Argocd application that point to a folder that contain a collection of application resources, which in turn point to the application manifests (deployment,svc….)</li>
</ul>
<figure class="image"><img src="/appsofapps.png"></figure>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: app-of-apps
  namespace: argocd
spec:
  project: default
  source:
    repoURL: http://165.22.209.118:3000/siddharth/gitops-argocd.git
    targetRevision: HEAD
    path: ./declarative/app-of-apps
  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
  syncPolicy:
    automated:
      prune: true
      selfHeal: true</code></pre>
<h3>Helm Charts</h3>
<ul>
  <li>using helm chart in a git repo and the applications managed by argocd not helm</li>
</ul>
<pre><code class="language-plaintext">argocd login http://10.200.130.134:32000/ --username admin --password P@ssw0rd --insecure</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext"> argocd app create helm-random-shapes \
&gt; --repo http://10.200.130.134:3000/ibrahim/gitops-argocd.git \
&gt; --path helm-chart \
&gt; --helm-set replicaCount=2 \
&gt; --helm-set color.circle=pink \
&gt; --helm-set color.square=black \
&gt; --helm-set service.type=NodePort \
&gt; --dest-namespace default \
&gt; --dest-cluster https://kubernetes.default.svc</code></pre>
<p>&nbsp;</p>
<ul>
  <li>using the helm repos<ul>
      <li>create a helm repo in argocd</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">argocd repo add https://charts.bitnami.com/bitnami   --type helm   --name bitnami</code></pre>
<h3>Adding clusters to Argocd</h3>
<ul>
  <li>Argocd takes data from the .kube/config file to add new clusters, so create a new context with a user that can create sa and grant cluster-admin clusterrole because argocd will create them using this user.</li>
</ul>
<pre><code class="language-plaintext">kubectl config set-credentials name --token or --client-certificate --client-key</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">kuectl config set-cluster name --server=apiserver --certificate-authority=file or use insecure-skip-tls-verify: true without the --certificate-authority=file</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">kubectl config set-context name --cluster= --user= --namespace</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">argocd cluster add context</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>the credentials are stored in argocd namespace as secret&nbsp;</p>
</blockquote>
<p>&nbsp;</p>
