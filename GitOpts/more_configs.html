<!--
title: More_configs
description: 
published: true
date: 2025-12-31T18:45:53.273Z
tags: 
editor: ckeditor
dateCreated: 2025-12-31T04:37:31.808Z
-->

<h3>RBAC</h3>
<ul>
  <li>policies are defined in CSV notation and applied to a user or a group</li>
</ul>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td>Project Level objects like applications, logs, exec</td>
        <td>p(policy), &lt;role/user/group&gt;, &nbsp;&lt;resource&gt;,&lt;action&gt;, &lt;project/object&gt;, &lt;effect&gt;</td>
        <td>g(group), user/group, role</td>
      </tr>
      <tr>
        <td>Other resources&nbsp;</td>
        <td>p(policy), &lt;role/user/group&gt;, &nbsp;&lt;resource&gt;,&lt;action&gt;, &lt;object&gt;, &lt;effect&gt;</td>
        <td>g(group), user/group, role</td>
      </tr>
    </tbody>
  </table>
</figure>
<ul>
  <li>Add RBAC policies to the argocd-rbac-cm</li>
  <li>argocd has two built in policies admin, readonly</li>
</ul>
<pre><code class="language-plaintext">kubectl -n argocd patch configmap argocd-rbac-cm \
--patch='{"data": {"policy.csv": "p, role:create-cluster, clusters, create, *, allow\ng, username, role:create-cluster"}}' </code></pre>
<pre><code class="language-plaintext">argocd account can-i create clusters '*'</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>the \n is for new line</p>
  <p>g(<strong>Group)</strong>: Allows to assign authenticated users/groups to internal roles.</p>
</blockquote>
<pre><code class="language-plaintext">apiVersion: v1
data:
  policy.csv: |-
    p, role:create-cluster, clusters, create, *, allow
    g, test, role: create-cluster
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/name: argocd-rbac-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-rbac-cm
  namespace: argocd</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Argocd supports local users and SSO using dex okta connector</li>
  <li>Local users are stored in argocd-cm by accounts.username: apikey, login and accouts.SID.enabled: “false”</li>
</ul>
<pre><code class="language-plaintext">kubectl -n argocd patch configmap argocd-cm --patch='{"data": {"accounts.username": "apiKey, login"}}' </code></pre>
<pre><code class="language-plaintext">apiVersion: v1
data:
  accounts.test: apiKey, login
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-cm
  namespace: argocd</code></pre>
<p>&nbsp;</p>
<ul>
  <li>use argocd account to update a password</li>
</ul>
<pre><code class="language-plaintext">argocd account update-password --account test --new-passowrd --current-password=admin passowrd</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To set a default role for any user who is not mapped to another roles</li>
</ul>
<pre><code class="language-plaintext">kubectl -n argocd patch cm argocd-rbac-cm --patch='{"data": {"policy.default": "role: readonly"}}'</code></pre>
<h3>Bitnami Sealed secrets</h3>
<ul>
  <li>Only the controller running in the target cluster can decrypt the sealed secret</li>
  <li>kubeseal client can be used to encrypt secrets</li>
</ul>
<pre><code class="language-plaintext">kubeseal -o yaml --scope cluster-wide --cert sealedsecret.crt &lt; secret.yaml &gt; sealedsecret.yaml</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Installation via helm chart https://bitnami-labs.github.io/sealed-secrets in the kube-system namespace</li>
  <li>Install the cli</li>
</ul>
<pre><code class="language-plaintext"># Fetch the latest sealed-secrets version using GitHub API
KUBESEAL_VERSION=$(curl -s https://api.github.com/repos/bitnami-labs/sealed-secrets/tags | jq -r '.[0].name' | cut -c 2-)

# Check if the version was fetched successfully
if [ -z "$KUBESEAL_VERSION" ]; then
    echo "Failed to fetch the latest KUBESEAL_VERSION"
    exit 1
fi

curl -OL "https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBESEAL_VERSION}/kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz"
tar -xvzf kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz kubeseal
sudo install -m 755 kubeseal /usr/local/bin/kubeseal</code></pre>
<p>&nbsp;</p>
<ul>
  <li>fetch the controller public certificates</li>
</ul>
<pre><code class="language-plaintext"> k get secret -n kube-system sealed-secrets-keyvtnbm -ojson | jq .data'."tls.crt"' -r | base64 -d  &gt; cert.crt</code></pre>
<p>&nbsp;</p>
<ul>
  <li>seal the secret</li>
</ul>
<pre><code class="language-plaintext">kubeseal -o yaml --cert cert.crt --scope cluster-wide &lt; secret.yaml  &gt; sealedsecret.yaml</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  annotations:
    sealedsecrets.bitnami.com/cluster-wide: "true"
  name: test
spec:
  encryptedData:
    name: AgCzp27XkIIiYehBzbRImvCtw8FsKFsNQDlRJoQyeEg6JjtXOFKGtFAVkrRpJjOurTkIRAziu5VMCl9rREyLcT/NFjGRgZCSNu4oY9Jdd3m1Qm4ACTa0M34yjwQZK9u0m59/5l2zH1/Nn1m0UPD9261VxShJA59FjOSmMo4tnohIInLAov1ymjcuz03oYx6TuVesiYQHXg9JYXdbS6flJeT52dqdlxhF3jqOJlhw1eo4JsDVyTQwXo9zz8OkddBN3ff1ngb6/y1K7A1qYQNnM9q3kqkoRhPVJfVLHNR64yKkmXDug+AhPwnyV2uoI26mxB8X7rMNUbHcTMcSp7fyqnIFUkxp2H4p+iCp+OXieYAhLcLz8N9SAmYf/TIzN+3KpMnf2gE+keljHfNnW7jKHaOrmWDUzFpnqpxwV0WJuXgv6MTfBnV+umYQhizu9sSjiF6YgIq2J/ukzdKGhFxUdePtfgKtouwNiCK0RQ/kEFYUoQXwrg41lL8k7+0A6c4sUMwNlupps4V4E7eklxF/4wrjDsVPiQMGd4NbGBkHn5B+axkiPP3Y//3hLFbSzUjkIQG85mHmXrECOpZ9Ko/dcQIrvATixgzm/EPTynsdHdIf+4GMch26MNQMCl7YWdlYno/SW2gzhhkobwsyX9ShjKk31b5BOGVCYrVdlR8fDUXYJwxE/ci23Ul76XbE8vEXvek/ImYmkvkRmg==
  template:
    metadata:
      annotations:
        sealedsecrets.bitnami.com/cluster-wide: "true"
      name: test
</code></pre>
<h3>Vault plugin&nbsp;</h3>
<ul>
  <li>Custom argocd plugin that inject secrets into &nbsp;k8s resources after retrieving them from vault.</li>
  <li>vault stores the secrets as plain text, so in the k8s secrets use stringData instead of data key word with the key of the secret in vault as value in a placeholder<mark class="marker-yellow"> &lt;vault_key&gt;</mark></li>
</ul>
<pre><code class="language-plaintext">apiVersion: v1
kind: Secret
metadata:
 name: vault
 annotations:
   avp.kubernetes.io/path: "creds/data/apps"
type: Opaque
stringData:
 name: &lt;name&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>the plugin uses<mark class="marker-yellow"> avp.kubernetes.io/path: path</mark> annotation to retrieve the secrets from vault after authentication</li>
  <li>The authentication can be done by putting the credentials in valut.env file</li>
</ul>
<pre><code class="language-plaintext">VAULT_ADDR=
VAULT_TOKEN=
AVP_TYPE=vault
AVP_AUTH_TYPE=token</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>There are two ways to add plugins to argocd&nbsp;</p>
  <ol>
    <li>configMaps</li>
    <li>sidecar plugin</li>
  </ol>
</blockquote>
<ul>
  <li>Adding plugins using ConfigMaps<ul>
      <li>add empty dir volume to the argocd-server deployment, and mount in to <mark class="marker-yellow">custom-tools</mark> dir</li>
      <li>use initcontainer to download and install the plugin into the custom-tools dir</li>
      <li>register the plugin to argocd &nbsp;in the argocd-cm</li>
      <li>restart the argocd server</li>
      <li>create a secret with valut.env for authentication</li>
    </ul>
  </li>
</ul>
<p>&nbsp;</p>
<h4>install the argocd-vault plugin on the bastion</h4>
<pre><code class="language-plaintext">wget https://github.com/argoproj-labs/argocd-vault-plugin/releases/download/v1.18.1/argocd-vault-plugin_1.18.1_linux_amd64
mv argocd-vault-plugin_1.18.1_linux_amd64 argocd-vault-plugin
chmod +x argocd-vault-plugin
mv argocd-vault-plugin /usr/local/bin</code></pre>
<p>&nbsp;</p>
<ul>
  <li>create a cofnig file with vault address and credentials in &nbsp;<mark class="marker-yellow">vault.env</mark> file</li>
</ul>
<pre><code class="language-plaintext">VAULT_ADDR=http://10.200.130.134:32001
VAULT_TOKEN=hvs.Nnr1UPPHPVppHd430vr1HZXd
AVP_TYPE=vault
AVP_AUTH_TYPE=token</code></pre>
<p>&nbsp;</p>
<ul>
  <li>generate the yaml file</li>
</ul>
<pre><code class="language-plaintext">argocd-vault-plugin generate -c  vault.env - &lt; secret.yaml</code></pre>
<h3>Installing vault plugin in argocd</h3>
<ul>
  <li>There are many options to add vault plugin to argocd one of them is using initcontainers</li>
</ul>
<pre><code class="language-plaintext">apiVersion: apps/v1
kind: Deployment
metadata:
  name: argocd-repo-server
spec:
  template:
    spec:
      containers:
      - name: argocd-repo-server
        volumeMounts:
        - name: custom-tools
          mountPath: /usr/local/bin/argocd-vault-plugin
          subPath: argocd-vault-plugin
        # Note: AVP config (for the secret manager, etc) can be passed in several ways. This is just one example
        # https://argocd-vault-plugin.readthedocs.io/en/stable/config/
        envFrom:
          - secretRef:
              name: argocd-vault-plugin-credentials
      volumes:
      - name: custom-tools
        emptyDir: {}
      initContainers:
      - name: download-tools
        image: alpine:3.8
        command: [sh, -c]
        # Don't forget to update this to whatever the stable release version is
        # Note the lack of the `v` prefix unlike the git tag
        env:
          - name: AVP_VERSION
            value: "1.18.1"
        args:
          - &gt;-
            wget -O argocd-vault-plugin
            https://github.com/argoproj-labs/argocd-vault-plugin/releases/download/v${AVP_VERSION}/argocd-vault-plugin_${AVP_VERSION}_linux_amd64 &amp;&amp;
            chmod +x argocd-vault-plugin &amp;&amp;
            mv argocd-vault-plugin /custom-tools/
        volumeMounts:
          - mountPath: /custom-tools
            name: custom-tools
      # Not strictly necessary, but required for passing AVP configuration from a secret and for using Kubernetes auth to Hashicorp Vault
      automountServiceAccountToken: true</code></pre>
<ul>
  <li>register the plugin in argocd-cm</li>
</ul>
<pre><code class="language-plaintext">data:
  configManagementPlugins: |-
    - name: argocd-vault-plugin
      generate:
        command: ["argocd-vault-plugin"]
        args: ["generate", "./"]</code></pre>
