<!--
title: More_configs
description: 
published: true
date: 2026-01-02T13:44:17.673Z
tags: 
editor: ckeditor
dateCreated: 2025-12-31T04:37:31.808Z
-->

<h3>RBAC</h3>
<ul>
  <li>policies are defined in CSV notation and applied to a user or a group</li>
</ul>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td>Project Level objects like applications, logs, exec</td>
        <td>p(policy), &lt;role/user/group&gt;, &nbsp;&lt;resource&gt;,&lt;action&gt;, &lt;project/object&gt;, &lt;effect&gt;</td>
        <td>g(group), user/group, role</td>
      </tr>
      <tr>
        <td>Other resources&nbsp;</td>
        <td>p(policy), &lt;role/user/group&gt;, &nbsp;&lt;resource&gt;,&lt;action&gt;, &lt;object&gt;, &lt;effect&gt;</td>
        <td>g(group), user/group, role</td>
      </tr>
    </tbody>
  </table>
</figure>
<ul>
  <li>Add RBAC policies to the argocd-rbac-cm</li>
  <li>argocd has two built in policies admin, readonly</li>
</ul>
<pre><code class="language-plaintext">kubectl -n argocd patch configmap argocd-rbac-cm \
--patch='{"data": {"policy.csv": "p, role:create-cluster, clusters, create, *, allow\ng, username, role:create-cluster"}}' </code></pre>
<pre><code class="language-plaintext">argocd account can-i create clusters '*'</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>the \n is for new line</p>
  <p>g(<strong>Group)</strong>: Allows to assign authenticated users/groups to internal roles.</p>
</blockquote>
<pre><code class="language-plaintext">apiVersion: v1
data:
  policy.csv: |-
    p, role:create-cluster, clusters, create, *, allow
    g, test, role: create-cluster
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/name: argocd-rbac-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-rbac-cm
  namespace: argocd</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Argocd supports local users and SSO using dex okta connector</li>
  <li>Local users are stored in argocd-cm by accounts.username: apikey, login and accouts.SID.enabled: “false”</li>
</ul>
<pre><code class="language-plaintext">kubectl -n argocd patch configmap argocd-cm --patch='{"data": {"accounts.username": "apiKey, login"}}' </code></pre>
<pre><code class="language-plaintext">apiVersion: v1
data:
  accounts.test: apiKey, login
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-cm
  namespace: argocd</code></pre>
<p>&nbsp;</p>
<ul>
  <li>use argocd account to update a password</li>
</ul>
<pre><code class="language-plaintext">argocd account update-password --account test --new-passowrd --current-password=admin passowrd</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To set a default role for any user who is not mapped to another roles</li>
</ul>
<pre><code class="language-plaintext">kubectl -n argocd patch cm argocd-rbac-cm --patch='{"data": {"policy.default": "role: readonly"}}'</code></pre>
<h3>Bitnami Sealed secrets</h3>
<ul>
  <li>Only the controller running in the target cluster can decrypt the sealed secret</li>
  <li>kubeseal client can be used to encrypt secrets</li>
</ul>
<pre><code class="language-plaintext">kubeseal -o yaml --scope cluster-wide --cert sealedsecret.crt &lt; secret.yaml &gt; sealedsecret.yaml</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Installation via helm chart https://bitnami-labs.github.io/sealed-secrets in the kube-system namespace</li>
  <li>Install the cli</li>
</ul>
<pre><code class="language-plaintext"># Fetch the latest sealed-secrets version using GitHub API
KUBESEAL_VERSION=$(curl -s https://api.github.com/repos/bitnami-labs/sealed-secrets/tags | jq -r '.[0].name' | cut -c 2-)

# Check if the version was fetched successfully
if [ -z "$KUBESEAL_VERSION" ]; then
    echo "Failed to fetch the latest KUBESEAL_VERSION"
    exit 1
fi

curl -OL "https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBESEAL_VERSION}/kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz"
tar -xvzf kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz kubeseal
sudo install -m 755 kubeseal /usr/local/bin/kubeseal</code></pre>
<p>&nbsp;</p>
<ul>
  <li>fetch the controller public certificates</li>
</ul>
<pre><code class="language-plaintext"> k get secret -n kube-system sealed-secrets-keyvtnbm -ojson | jq .data'."tls.crt"' -r | base64 -d  &gt; cert.crt</code></pre>
<p>&nbsp;</p>
<ul>
  <li>seal the secret</li>
</ul>
<pre><code class="language-plaintext">kubeseal -o yaml --cert cert.crt --scope cluster-wide &lt; secret.yaml  &gt; sealedsecret.yaml</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  annotations:
    sealedsecrets.bitnami.com/cluster-wide: "true"
  name: test
spec:
  encryptedData:
    name: AgCzp27XkIIiYehBzbRImvCtw8FsKFsNQDlRJoQyeEg6JjtXOFKGtFAVkrRpJjOurTkIRAziu5VMCl9rREyLcT/NFjGRgZCSNu4oY9Jdd3m1Qm4ACTa0M34yjwQZK9u0m59/5l2zH1/Nn1m0UPD9261VxShJA59FjOSmMo4tnohIInLAov1ymjcuz03oYx6TuVesiYQHXg9JYXdbS6flJeT52dqdlxhF3jqOJlhw1eo4JsDVyTQwXo9zz8OkddBN3ff1ngb6/y1K7A1qYQNnM9q3kqkoRhPVJfVLHNR64yKkmXDug+AhPwnyV2uoI26mxB8X7rMNUbHcTMcSp7fyqnIFUkxp2H4p+iCp+OXieYAhLcLz8N9SAmYf/TIzN+3KpMnf2gE+keljHfNnW7jKHaOrmWDUzFpnqpxwV0WJuXgv6MTfBnV+umYQhizu9sSjiF6YgIq2J/ukzdKGhFxUdePtfgKtouwNiCK0RQ/kEFYUoQXwrg41lL8k7+0A6c4sUMwNlupps4V4E7eklxF/4wrjDsVPiQMGd4NbGBkHn5B+axkiPP3Y//3hLFbSzUjkIQG85mHmXrECOpZ9Ko/dcQIrvATixgzm/EPTynsdHdIf+4GMch26MNQMCl7YWdlYno/SW2gzhhkobwsyX9ShjKk31b5BOGVCYrVdlR8fDUXYJwxE/ci23Ul76XbE8vEXvek/ImYmkvkRmg==
  template:
    metadata:
      annotations:
        sealedsecrets.bitnami.com/cluster-wide: "true"
      name: test
</code></pre>
<h3>Vault plugin&nbsp;</h3>
<ul>
  <li>Custom argocd plugin that inject secrets into &nbsp;k8s resources after retrieving them from vault.</li>
  <li>vault stores the secrets as plain text, so in the k8s secrets use stringData instead of data key word with the key of the secret in vault as value in a placeholder<mark class="marker-yellow"> &lt;vault_key&gt;</mark></li>
</ul>
<pre><code class="language-plaintext">apiVersion: v1
kind: Secret
metadata:
 name: vault
 annotations:
   avp.kubernetes.io/path: "creds/data/apps"
type: Opaque
stringData:
 name: &lt;name&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>the plugin uses<mark class="marker-yellow"> avp.kubernetes.io/path: path</mark> annotation to retrieve the secrets from vault after authentication</li>
  <li>The authentication can be done by putting the credentials in valut.env file</li>
</ul>
<pre><code class="language-plaintext">VAULT_ADDR=
VAULT_TOKEN=
AVP_TYPE=vault
AVP_AUTH_TYPE=token</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>There are two ways to add plugins to argocd&nbsp;</p>
  <ol>
    <li>configMaps</li>
    <li>sidecar plugin</li>
  </ol>
</blockquote>
<ul>
  <li>Adding plugins using ConfigMaps<ul>
      <li>add empty dir volume to the argocd-server deployment, and mount in to <mark class="marker-yellow">custom-tools</mark> dir</li>
      <li>use initcontainer to download and install the plugin into the custom-tools dir</li>
      <li>register the plugin to argocd &nbsp;in the argocd-cm</li>
      <li>restart the argocd server</li>
      <li>create a secret with valut.env for authentication</li>
    </ul>
  </li>
</ul>
<p>&nbsp;</p>
<h4>install the argocd-vault plugin on the bastion</h4>
<pre><code class="language-plaintext">wget https://github.com/argoproj-labs/argocd-vault-plugin/releases/download/v1.18.1/argocd-vault-plugin_1.18.1_linux_amd64
mv argocd-vault-plugin_1.18.1_linux_amd64 argocd-vault-plugin
chmod +x argocd-vault-plugin
mv argocd-vault-plugin /usr/local/bin</code></pre>
<p>&nbsp;</p>
<ul>
  <li>create a cofnig file with vault address and credentials in &nbsp;<mark class="marker-yellow">vault.env</mark> file</li>
</ul>
<pre><code class="language-plaintext">VAULT_ADDR=http://10.200.130.134:32001
VAULT_TOKEN=hvs.Nnr1UPPHPVppHd430vr1HZXd
AVP_TYPE=vault
AVP_AUTH_TYPE=token</code></pre>
<p>&nbsp;</p>
<ul>
  <li>generate the yaml file</li>
</ul>
<pre><code class="language-plaintext">argocd-vault-plugin generate -c  vault.env - &lt; secret.yaml</code></pre>
<h3>Installing vault plugin in argocd</h3>
<ul>
  <li>There are many options to add vault plugin to argocd one of them is using initcontainers to the&nbsp;<code> argocd-repo-server deployment</code></li>
</ul>
<blockquote>
  <p><code>Old method and did not work at all because it is deprecated in 2.7 and removed in 2.8</code></p>
</blockquote>
<pre><code class="language-plaintext">apiVersion: apps/v1
kind: Deployment
metadata:
  name: argocd-repo-server
spec:
  template:
    spec:
      containers:
      - name: argocd-repo-server
        volumeMounts:
        - name: custom-tools
          mountPath: /usr/local/bin/argocd-vault-plugin
          subPath: argocd-vault-plugin
        # Note: AVP config (for the secret manager, etc) can be passed in several ways. This is just one example
        # https://argocd-vault-plugin.readthedocs.io/en/stable/config/
        envFrom:
          - secretRef:
              name: argocd-vault-plugin-credentials
      volumes:
      - name: custom-tools
        emptyDir: {}
      initContainers:
      - name: download-tools
        image: alpine:3.8
        command: [sh, -c]
        # Don't forget to update this to whatever the stable release version is
        # Note the lack of the `v` prefix unlike the git tag
        env:
          - name: AVP_VERSION
            value: "1.18.1"
        args:
          - &gt;-
            wget -O argocd-vault-plugin
            https://github.com/argoproj-labs/argocd-vault-plugin/releases/download/v${AVP_VERSION}/argocd-vault-plugin_${AVP_VERSION}_linux_amd64 &amp;&amp;
            chmod +x argocd-vault-plugin &amp;&amp;
            mv argocd-vault-plugin /custom-tools/
        volumeMounts:
          - mountPath: /custom-tools
            name: custom-tools
      # Not strictly necessary, but required for passing AVP configuration from a secret and for using Kubernetes auth to Hashicorp Vault
      automountServiceAccountToken: true</code></pre>
<p>&nbsp;</p>
<ul>
  <li>register the plugin in argocd-cm</li>
</ul>
<pre><code class="language-plaintext">data:
  configManagementPlugins: |-
    - name: argocd-vault-plugin
      generate:
        command: ["argocd-vault-plugin"]
        args: ["generate", "./"]</code></pre>
<p>&nbsp;</p>
<ul>
  <li>create the <code>argocd-vault-plugin-credentials&nbsp;</code> secret</li>
</ul>
<pre><code class="language-plaintext">apiVersion: v1
kind: Secret
metadata:
 name:  argocd-vault-plugin-credentials
type: Opaque
stringData:
  VAULT_ADDR: http://10.200.130.134:32001
  VAULT_TOKEN: hvs.Nnr1UPPHPVppHd430vr1HZXd
  AVP_TYPE: vault
  AVP_AUTH_TYPE: token</code></pre>
<h4>Config Management plugins</h4>
<ul>
  <li>There are two steps to configure a custom plugin which are creating the plugin configuration file and</li>
  <li>ConfigManagementPlugin resource is a resource that used by argocd server and is located in the plugin container</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: ConfigManagementPlugin
metadata:
  # The name of the plugin must be unique within a given Argo CD instance.
  name: my-plugin
spec:
  # The version of your plugin. Optional. If specified, the Application's spec.source.plugin.name field
  # must be &lt;plugin name&gt;-&lt;plugin version&gt;.
  version: v1.0
  # The init command runs in the Application source directory at the beginning of each manifest generation. The init
  # command can output anything. A non-zero status code will fail manifest generation.
  init:
    # Init always happens immediately before generate, but its output is not treated as manifests.
    # This is a good place to, for example, download chart dependencies.
    command: [sh]
    args: [-c, 'echo "Initializing..."']
  # The generate command runs in the Application source directory each time manifests are generated. Standard output
  # must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation.
  # To write log messages from the command, write them to stderr, it will always be displayed.
  # Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
  generate:
    command: [sh, -c]
    args:
      - |
        echo "{\"kind\": \"ConfigMap\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"$ARGOCD_APP_NAME\", \"namespace\": \"$ARGOCD_APP_NAMESPACE\", \"annotations\": {\"Foo\": \"$ARGOCD_ENV_FOO\", \"KubeVersion\": \"$KUBE_VERSION\", \"KubeApiVersion\": \"$KUBE_API_VERSIONS\",\"Bar\": \"baz\"}}}"
  # The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be
  # used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin 
  # will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. 
  # Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the 
  # first (in that order) is evaluated.
  discover:
    # fileName is a glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source 
    # directory. If there is a match, this plugin may be used for the Application.
    fileName: "./subdir/s*.yaml"
    find:
      # This does the same thing as fileName, but it supports double-star (nested directory) glob patterns.
      glob: "**/Chart.yaml"
      # The find command runs in the repository's root directory. To match, it must exit with status code 0 _and_ 
      # produce non-empty output to standard out.
      command: [sh, -c, find . -name env.yaml]
  # The parameters config describes what parameters the UI should display for an Application. It is up to the user to
  # actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements _only_
  # inform the "Parameters" tab in the App Details page of the UI.
  parameters:
    # Static parameter announcements are sent to the UI for _all_ Applications handled by this plugin.
    # Think of the `string`, `array`, and `map` values set here as "defaults". It is up to the plugin author to make 
    # sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different
    # values for those parameters.
    static:
      - name: string-param
        title: Description of the string param
        tooltip: Tooltip shown when the user hovers the
        # If this field is set, the UI will indicate to the user that they must set the value.
        required: false
        # itemType tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is
        # "string". Examples of other types which may be supported in the future are "boolean" or "number".
        # Even if the itemType is not "string", the parameter value from the Application spec will be sent to the plugin
        # as a string. It's up to the plugin to do the appropriate conversion.
        itemType: ""
        # collectionType describes what type of value this parameter accepts (string, array, or map) and allows the UI
        # to present a form to match that type. Default is "string". This field must be present for non-string types.
        # It will not be inferred from the presence of an `array` or `map` field.
        collectionType: ""
        # This field communicates the parameter's default value to the UI. Setting this field is optional.
        string: default-string-value
      # All the fields above besides "string" apply to both the array and map type parameter announcements.
      - name: array-param
        # This field communicates the parameter's default value to the UI. Setting this field is optional.
        array: [default, items]
        collectionType: array
      - name: map-param
        # This field communicates the parameter's default value to the UI. Setting this field is optional.
        map:
          some: value
        collectionType: map
    # Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example,
    # the values for a Helm chart's values.yaml file could be sent as parameter announcements.
    dynamic:
      # The command is run in an Application's source directory. Standard output must be JSON matching the schema of the
      # static parameter announcements list.
      command: [echo, '[{"name": "example-param", "string": "default-string-value"}]']

  # If set to `true` then the plugin receives repository files with original file mode. Dangerous since the repository
  # might have executable files. Set to true only if you trust the CMP plugin authors.
  preserveFileMode: false

  # If set to `true` then the plugin can retrieve git credentials from the reposerver during generate. Plugin authors 
  # should ensure these credentials are appropriately protected during execution
  provideGitCreds: false</code></pre>
<p>&nbsp;</p>
<ul>
  <li>mount the ConfigManagementPlugin file to the sidecar</li>
</ul>
<pre><code class="language-plaintext">apiVersion: v1
kind: ConfigMap
metadata:
  name: my-plugin-config
data:
  plugin.yaml: |
    apiVersion: argoproj.io/v1alpha1
    kind: ConfigManagementPlugin
    metadata:
      name: my-plugin
    spec:
      version: v1.0
      init:
        command: [sh, -c, 'echo "Initializing..."']
      generate:
        command: [sh, -c, 'echo "{\"kind\": \"ConfigMap\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"$ARGOCD_APP_NAME\", \"namespace\": \"$ARGOCD_APP_NAMESPACE\", \"annotations\": {\"Foo\": \"$ARGOCD_ENV_FOO\", \"KubeVersion\": \"$KUBE_VERSION\", \"KubeApiVersion\": \"$KUBE_API_VERSIONS\",\"Bar\": \"baz\"}}}"']
      discover:
        fileName: "./subdir/s*.yaml"</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Register the plugin sidecar</li>
</ul>
<pre><code class="language-plaintext">containers:
- name: my-plugin
  command: [/var/run/argocd/argocd-cmp-server] # Entrypoint should be Argo CD lightweight CMP server i.e. argocd-cmp-server
  image: ubuntu # This can be off-the-shelf or custom-built image
  securityContext:
    runAsNonRoot: true
    runAsUser: 999
  volumeMounts:
    - mountPath: /var/run/argocd
      name: var-files
    - mountPath: /home/argocd/cmp-server/plugins
      name: plugins
    # Remove this volumeMount if you've chosen to bake the config file into the sidecar image.
    - mountPath: /home/argocd/cmp-server/config/plugin.yaml
      subPath: plugin.yaml
      name: my-plugin-config
    # Starting with v2.4, do NOT mount the same tmp volume as the repo-server container. The filesystem separation helps 
    # mitigate path traversal attacks.
    - mountPath: /tmp
      name: cmp-tmp
volumes:
- configMap:
    name: my-plugin-config
  name: my-plugin-config
- emptyDir: {}
  name: cmp-tmp</code></pre>
<h3>CMP for vault (in-house)</h3>
<pre><code class="language-plaintext">apiVersion: v1
kind: ConfigMap
metadata:
   name: cmp-plugin
   namespace: argocd
data:
  avp.yaml: |
    apiVersion: argoproj.io/v1alpha1
    kind: ConfigManagementPlugin
    metadata:
      name: argocd-vault-plugin
      namespace: argocd
    spec:
      allowConcurrency: true
      discover:
        find:
          command:
            - sh
            - "-c"
            - "find . -name '*.yaml' ! -name '*values.yaml' | xargs -I {} grep \"&lt;path\\|avp\\.kubernetes\\.io\" {} | grep ."
      generate:
        command:
          - sh
          - "-c"
          - "for file in $(find . -type f -name '*.yaml' ! -name 'values.yaml' ! -path '*/statics/*'); do argocd-vault-plugin generate --verbose-sensitive-output \"$file\"; done"
      lockRepo: false
  avp-helm.yaml: |
    apiVersion: argoproj.io/v1alpha1
    kind: ConfigManagementPlugin
    metadata:
      name: argocd-vault-plugin-helm
    spec:
      allowConcurrency: true
      discover:
        find:
          command:
            - sh
            - "-c"
            - "find . -name 'Chart.yaml' | grep -qz . &amp;&amp; find . -name 'values.yaml'"
      generate:
        command:
          - sh
          - "-c"
          - |
            helm template $ARGOCD_APP_NAME --include-crds . |
            argocd-vault-plugin generate -
      lockRepo: false
</code></pre>
<ul>
  <li>The init container that will install the binary</li>
</ul>
<pre><code class="language-plaintext">      - name: download-tools
        image: alpine:3.8
        env:
        - name: AVP_VERSION
          value: 1.18.1
        command: [sh, -c]
        args: 
        - wget -O argocd-vault-plugin https://github.com/argoproj-labs/argocd-vault-plugin/releases/download/v${AVP_VERSION}/argocd-vault-plugin_${AVP_VERSION}_linux_amd64 &amp;&amp;chmod +x argocd-vault-plugin &amp;&amp; mv argocd-vault-plugin /custom-tools/
        volumeMounts:
        - mountPath: /custom-tools
          name: custom-tools
</code></pre>
<ul>
  <li>the volumes needed</li>
</ul>
<pre><code class="language-plaintext">      - configMap:
          name: cmp-plugin
        name: cmp-plugin
      - name: custom-tools
        emptyDir: {}
</code></pre>
<ul>
  <li>the sidecar container</li>
</ul>
<pre><code class="language-plaintext">      - name: avp
        command: [/var/run/argocd/argocd-cmp-server]
        image: ubuntu
        env:
          - name: ARGOCD_ENV_VAULT_ADDR
            value: "http://10.200.130.134:32001"
          - name: ARGOCD_ENV_VAULT_TOKEN
            value: "hvs.5HUKqLBfo2DqNUlc6FINmY6N"
          - name: ARGOCD_ENV_AVP_AUTH_TYPE
            value: "token"
          - name: ARGOCD_ENV_AVP_TYPE
            value : vault
        securityContext:
          runAsNonRoot: true
          runAsUser: 999
        volumeMounts:
          - mountPath: /var/run/argocd
            name: var-files
          - mountPath: /home/argocd/cmp-server/plugins
            name: plugins
          - mountPath: /tmp
            name: tmp
          # Register plugins into sidecar
          - mountPath: /home/argocd/cmp-server/config/plugin.yaml
            subPath: avp.yaml
            name: cmp-plugin
          # Important: Mount tools into $PATH
          - name: custom-tools
            subPath: argocd-vault-plugin
            mountPath: /usr/local/bin/argocd-vault-plugin
      - name: avp-helm
        command: [/var/run/argocd/argocd-cmp-server]
        image: quay.io/argoproj/argocd:v2.7.9
        env:
          - name: ARGOCD_ENV_VAULT_ADDR
            value: "http://10.200.130.134:32001"
          - name: ARGOCD_ENV_VAULT_TOKEN
            value: "hvs.5HUKqLBfo2DqNUlc6FINmY6N"
          - name: ARGOCD_ENV_AVP_AUTH_TYPE
            value: "token"
          - name: ARGOCD_ENV_AVP_TYPE
            value : vault
        securityContext:
          runAsNonRoot: true
          runAsUser: 999
        volumeMounts:
          - mountPath: /var/run/argocd
            name: var-files
          - mountPath: /home/argocd/cmp-server/plugins
            name: plugins
          - mountPath: /tmp
            name: tmp
          # Register plugins into sidecar
          - mountPath: /home/argocd/cmp-server/config/plugin.yaml
            subPath: avp-helm.yaml
            name: cmp-plugin

          # Important: Mount tools into $PATH
          - name: custom-tools
            subPath: argocd-vault-plugin
            mountPath: /usr/local/bin/argocd-vault-plugin
</code></pre>
<h3>Prometheus &amp; Garfana monitoring</h3>
<ul>
  <li>Argocd exposed metrics in these serveries:<ul>
      <li>argocd-metrics</li>
      <li>argocd-server-metrics</li>
      <li>argocd-applicationset-controller</li>
      <li>argocd-repo-server</li>
    </ul>
  </li>
  <li>promethues uses service monitor resource to monitor service based on labels and selectors</li>
  <li>promethues uses promethues monitoring resource to match to service monitoring resource based on labels and selectors and then create the configuration for promethues.</li>
  <li>promethues rules define alerts and alertmanager configs send alerts on a condition</li>
  <li>use these service monitors &nbsp;to expose metrics. Change the label to the release name of helm installation of prometheus</li>
</ul>
<pre><code class="language-plaintext">k get prometheuses.monitoring.coreos.com  -o yaml | grep -i servicemonitorselector -A5</code></pre>
<pre><code class="language-plaintext">apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: argocd-metrics
  labels:
    release: prometheus-operator
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-metrics
  endpoints:
    - port: metrics
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: argocd-server-metrics
  labels:
    release: prometheus-operator
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-server-metrics
  endpoints:
    - port: metrics
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: argocd-repo-server-metrics
  labels:
    release: prometheus-operator
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-repo-server
  endpoints:
    - port: metrics
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: argocd-applicationset-controller-metrics
  labels:
    release: prometheus-operator
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-applicationset-controller
  endpoints:
    - port: metrics
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: argocd-dex-server
  labels:
    release: prometheus-operator
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-dex-server
  endpoints:
    - port: metrics
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: argocd-redis-haproxy-metrics
  labels:
    release: prometheus-operator
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-redis-ha-haproxy
  endpoints:
    - port: http-exporter-port
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: argocd-notifications-controller
  labels:
    release: prometheus-operator
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-notifications-controller-metrics
  endpoints:
    - port: metrics</code></pre>
<ul>
  <li>For grafana dashboard import the dashboard from <a href="https://grafana.com/grafana/dashboards/14584-argocd/">ArgoCD | Grafana Labs</a></li>
  <li>For Alertmanager edit the promethuesrules to add custom argocd rules</li>
</ul>
<pre><code class="language-plaintext">k edit  prometheusrules promo-kube-prometheus-stac-alertmanager.rules</code></pre>
<pre><code class="language-plaintext">    - alert: ArgoApplicationOutOfSync
      annotations:
        summary: "'{{ $labels.name }}' application has a sync issue"
      expr: argocd_app_info{sync_status="OutOfSync"} == 1
      for: 1m
      labels:
        severity: warning

</code></pre>
<h4>Notifications</h4>
<ul>
  <li>Controller that alert users about argocd application status</li>
  <li>Slack<ul>
      <li>require token with the right permissions stored in argocd-notifications-secret</li>
      <li>configure the &nbsp;argocd-notifications-cm with the <mark class="marker-yellow">service.slack</mark></li>
      <li>&nbsp;patch the argocd application with annotation &nbsp;<mark class="marker-yellow">notifications.argocdproj.io/subscribe.on-sync-succeeded.slack: channel</mark></li>
      <li>Add a<mark class="marker-yellow"> trigger point and notification template and slack attachments&nbsp;</mark></li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">k edit secrets argocd-notifications-secret -n argocd</code></pre>
<pre><code class="language-plaintext">stringData:
  slack-token: xoxb-9057661131042-10224066058212-7csU3Zkdw1lFjavvgk8t3Xds
</code></pre>
<ul>
  <li>edit the argocd-cm to add a trigger and message template</li>
</ul>
<pre><code class="language-plaintext">k edit cm argocd-notifications-cm -n argocd</code></pre>
<pre><code class="language-plaintext">data:
  service.slack: |
    token: $slack-token
    username: argocd-bot
    icon: "rocket:"
  trigger.on-sync-succeeded: |
    - when: app.status.sync.status == 'Synced'     # trigger condition
      send: [app-sync-succceeded-slack] # template names
  template.app-sync-succceeded-slack: |
    message: |
      Application {{.app.metadata.name}} sync is {{.app.status.sync.status}}.

</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
