<!--
title: Concepts
description: 
published: true
date: 2026-01-03T18:58:32.047Z
tags: 
editor: ckeditor
dateCreated: 2025-12-29T09:23:18.217Z
-->

<h1>What is GitOps</h1>
<ul>
  <li>Without GitOps, operations that are done manually in clusters will lead to a configuration drift, which could lead to down time in the service.</li>
</ul>
<blockquote>
  <p>managing infra and apps using Git as the single source of truth for declarative configuration, with automated reconciliation.</p>
</blockquote>
<ul>
  <li>GitOps is a framework where the entire code deliver process is controlled by git allowing to do rollbacks, operations, and releases seamlessly</li>
  <li>It extends the IaCs to use Git as a control system with the source code of the applications</li>
  <li>GitOps operator like ArgoCD continuously compare the actual state to the state exist in Git</li>
  <li>Reduce the risk of allowing builder tools to have access to the clusters by using pull based deployment.</li>
</ul>
<h4>Principles&nbsp;</h4>
<ol>
  <li>Declarative vs imperative.</li>
  <li>Git as source of the truth</li>
  <li>Software agents (GitOps operators) pull the state from Git and apply it to the target platform</li>
  <li>Reconciliation loops for self-healing (observe-diff-act)</li>
</ol>
<h3>Terms</h3>
<ul>
  <li>Continuous: ongoing process to ensure that the system is in its desired state</li>
  <li>Declarative, Desired state, Actual state for well defined unified configuration and prevent <mark class="marker-yellow">state drift&nbsp;</mark></li>
</ul>
<figure class="image"><img src="/state.png"></figure>
<ul>
  <li>Self-healing to correct the deviation &nbsp;in <mark class="marker-yellow">GitOps Managed Software System</mark></li>
  <li>State store &gt; GIT and OCI (open container initiative )</li>
  <li>Feedback Loops: The process of observing the actual state of the system by collecting logs, metrics, and alerts data that is analyzed and use this information to improve the desired state.</li>
</ul>
<figure class="image"><img src="/loop.png"></figure>
<ul>
  <li>Rollback: manual or automatic fall back to functional state</li>
</ul>
<h4>DevOps vs GitOps</h4>
<ul>
  <li>DevOps works with any application, but GitOps works best with containerized applications. DevOps push the changes to the target platform unlike the GitOps operator that usually &nbsp;pulls the state.</li>
  <li>GitOps usually has two repos &nbsp;one for source code and another for the IaC files.</li>
  <li>The DevOps pipeline will build the container image, pulls the manifests from the IaC repo, and then it modified the manifests with the tag of the created image and push the modified files to the Iac repo.</li>
  <li>The GitOps operator will pull the state from the IaC repo and apply them to the target platform.</li>
</ul>
<figure class="image"><img src="/argo.png"></figure>
<ul>
  <li><mark class="marker-yellow">challenges with secret management in the GitOps</mark></li>
</ul>
<h3>GitOps Reconciler types</h3>
<ol>
  <li>In-Cluster: Runs on the target cluster and use the l<mark class="marker-yellow">ocal API service and pulls the state</mark>. Do not require exposing the API server outside the cluster<ul>
      <li>Argocd can act as both types, and must explicitly configured to connect to the external clusters.</li>
    </ul>
  </li>
  <li>External: &nbsp;The Operator connect to the external API-Server to<mark class="marker-yellow"> push stateto the target the clusters</mark>, which might introduces security risks</li>
</ol>
<h4>Well known tools</h4>
<ul>
  <li>ArgoCD</li>
  <li>FluxCD</li>
  <li>Atlantis for terraform</li>
  <li>Helm operator</li>
  <li>ignite for vitraul machines management</li>
</ul>
<h1>ArgoCD</h1>
<ul>
  <li>It works with kustomize, Helm charts, ksonnet applications, Jsonnet files, Yaml / Json manfiests</li>
  <li>Integrates with SSO solutions</li>
  <li>Audit trails for application events and API calls</li>
  <li>WebHook integration with Git servers</li>
  <li>Detect configuration drift</li>
  <li>Prometheus metrics</li>
  <li>expose gRPC REST APIs</li>
</ul>
<figure class="image"><img src="/archee.png"></figure>
<h4>Terminology</h4>
<ul>
  <li>Applications: is a crd that create when ArgoCd is deployed, and groups some kubernetes resources defined by a manifest</li>
  <li>Application source type: The tool that is used to build the applications (helm, kustomize…)</li>
  <li>Project: logical grouping of applications</li>
  <li>States:<ul>
      <li>Target state: &nbsp;the desired state</li>
      <li>Live state: &nbsp;the actual one</li>
    </ul>
  </li>
  <li>Sync terms:<ul>
      <li>sync status: Does the target state matches the live state?</li>
      <li>sync: the process of making an application move to its target state</li>
      <li>sync operation status: &nbsp;whether the sync succeeded or not</li>
    </ul>
  </li>
  <li>Refresh: compares the target with the live</li>
  <li>Health: &nbsp;the application is up and running?</li>
  <li>Continues reconciliation == auto sync</li>
</ul>
<h3>Installation options</h3>
<ol>
  <li>core: &nbsp;minimal installation no api-server and UI</li>
  <li>Multi-Tenant:<ol>
      <li>HA: &nbsp;for Production, ha/install.yaml and ha/namespace-install.yaml</li>
      <li>Non HA: &nbsp;for POC, install.yaml cluster admin access and namespace-install.yaml for access to only one namespace.</li>
    </ol>
  </li>
</ol>
<h3>Installation</h3>
<ul>
  <li><a href="https://github.com/argoproj/argo-cd/releases">Releases · argoproj/argo-cd · GitHub</a></li>
</ul>
<pre><code class="language-plaintext">kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v3.2.3/manifests/install.yaml</code></pre>
<p>&nbsp;</p>
<ul>
  <li>install the argocd cli from the assets section in the release page</li>
  <li>the initial admin secret is saved in a secret called <mark class="marker-yellow">argocd-initial-admin-secret</mark></li>
</ul>
<h4>Apps and projects</h4>
<ul>
  <li>Application is a crd that define<ul>
      <li>source: repoURL, targetRevision, Path</li>
      <li>destination: target cluster, namespace</li>
      <li>project names it belongs to</li>
      <li>sync policy</li>
      <li>ignore diff</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
 name: guestbook
 namespace: argocd
spec:
 project: default
 source:
   repoURL: https://github.com/argoproj/argocd-example-apps.git
   targetRevision: HEAD
   path: guestbook
 destination:
   server: https://kubernetes.default.svc
   namespace: guestbook</code></pre>
<p>&nbsp;</p>
<ul>
  <li>argocd create k8s secrets with git server credentials</li>
  <li>To create application using cli</li>
</ul>
<pre><code class="language-plaintext">argocd app create name --repo --path --dest-namespace --dest-server https://kubernetes.default.svc</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To sync</li>
</ul>
<pre><code class="language-plaintext">argocd app sync name</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To create projects</li>
</ul>
<pre><code class="language-plaintext">argocd proj create -h</code></pre>
<p>&nbsp;</p>
<h3>Deployment strategies&nbsp;</h3>
<ol>
  <li>RollingUpdate: Replaces pods one by one after becoming ready ( default )</li>
  <li>Recreate: Terminate and create</li>
  <li>Blue Green: Two deployments Blue is active (current version) &nbsp;and green which is idle (new version). The traffic is switched from blue to green once the green deployment is validated<ul>
      <li>Needs two identical deployments</li>
    </ul>
  </li>
  <li>Canary deployment: &nbsp;gradual rollouts &nbsp;Releases new features to a small subset of users before expanding to the entire user base.<ul>
      <li>Needs two deployments and optional service mesh</li>
    </ul>
  </li>
</ol>
<h3>Argo Rollouts</h3>
<ul>
  <li>A controller and set of CRDs that support advanced deployment strategies, fine grade traffic control, automatic analysis, and rollback capabilities. ( integrates with service mesh and ingress controllers )</li>
</ul>
<h6>Installation</h6>
<pre><code class="language-plaintext">kubectl create namespace argo-rollouts
kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Download the cli from the release pages</li>
</ul>
<pre><code class="language-plaintext">wget https://github.com/argoproj/argo-rollouts/releases/download/v1.8.3/kubectl-argo-rollouts-linux-amd64
chmod +x kubectl-argo-rollouts-linux-amd64
mv kubectl-argo-rollouts-linux-amd64 /usr/bin/local/kubectl-argo-rollouts</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To show the UI</li>
</ul>
<pre><code class="language-plaintext">kubectl-argo-rollouts dashboard</code></pre>
<h6>Blue Green deployment with argo-rollout&nbsp;</h6>
<ul>
  <li>argo rollout manage<mark class="marker-yellow"> RepliaSets and services</mark> ( active and preview in the same namespace)</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: rollout-bluegreen
spec:
  replicas: 2
  revisionHistoryLimit: 2
  selector:
    matchLabels:
      app: rollout-bluegreen
  template:
    metadata:
      labels:
        app: rollout-bluegreen
    spec:
      containers:
      - name: rollouts-demo
        image: argoproj/rollouts-demo:blue
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
  strategy:
    blueGreen: 
      # activeService specifies the service to update with the new template hash at time of promotion.
      # This field is mandatory for the blueGreen update strategy.
      activeService: rollout-bluegreen-active
      # previewService specifies the service to update with the new template hash before promotion.
      # This allows the preview stack to be reachable without serving production traffic.
      # This field is optional.
      previewService: rollout-bluegreen-preview
      # autoPromotionEnabled disables automated promotion of the new stack by pausing the rollout
      # immediately before the promotion. If omitted, the default behavior is to promote the new
      # stack as soon as the ReplicaSet are completely ready/available.
      # Rollouts can be resumed using: `kubectl argo rollouts promote ROLLOUT`
      autoPromotionEnabled: false</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Both services use the same parameters expect the service names. In case of a rollout, the preview service will be used to handle the traffic of the new deployment by introduction a hash label to both the pods in the new deployment and the service selector</li>
</ul>
<pre><code class="language-plaintext">k get svc -n blue-green -o yaml
apiVersion: v1
items:
- apiVersion: v1
  kind: Service
  metadata:
    name: highway-bluegreen-active
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30838
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: 674c49d44d   &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort

- apiVersion: v1
  kind: Service
  metadata:
    name: highway-bluegreen-preview
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30168
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9   &gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">k get rs -n blue-green -o yaml
apiVersion: v1
items:
- apiVersion: apps/v1
  kind: ReplicaSet
  metadata:


    labels:
      app: highway-bluegreen
      rollouts-pod-template-hash: 674c49d44d       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    name: highway-bluegreen-674c49d44d
    namespace: blue-green
    ownerReferences:
    - apiVersion: argoproj.io/v1alpha1
      blockOwnerDeletion: true
      controller: true
      kind: Rollout
      name: highway-bluegreen

  spec:

    selector:

      matchLabels:
        app: highway-bluegreen
        rollouts-pod-template-hash: 674c49d44d  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    template:
      metadata:

        labels:
          app: highway-bluegreen
          rollouts-pod-template-hash: 674c49d44d  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

.......
- apiVersion: apps/v1
  kind: ReplicaSet
  metadata:

    labels:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    name: highway-bluegreen-d88b957f9
    namespace: blue-green
    ownerReferences:
    - apiVersion: argoproj.io/v1alpha1
      blockOwnerDeletion: true
      controller: true
      kind: Rollout
      name: highway-bluegreen

  spec:

    selector:
      matchLabels:
        app: highway-bluegreen
        rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    template:
      metadata:

        labels:
          app: highway-bluegreen
          rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here





</code></pre>
<ul>
  <li>To &nbsp;route the traffic to the newer version manually promote the preview version. Then argo rollouts will change the labels on the active service to adopt the new version pods and reduce the older replicaset version to zero replicas.</li>
</ul>
<pre><code class="language-plaintext">
- apiVersion: v1
  kind: Service
  metadata:

    name: highway-bluegreen-active
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30838
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort

- apiVersion: v1
  kind: Service
  metadata:

    name: highway-bluegreen-preview
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30168
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort
</code></pre>
<ul>
  <li>If you want to rollback use the dashboard or cli</li>
</ul>
<h6>Canary deployment</h6>
<ul>
  <li>Gradual rollout to eventually reach 100% of the new version by certain rate.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: example-rollout
spec:
  replicas: 10
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.15.4
          ports:
            - containerPort: 80
  minReadySeconds: 30
  revisionHistoryLimit: 3
  strategy:
    canary: #Indicates that the rollout should use the Canary strategy
      maxSurge: '25%'
      maxUnavailable: 0
      steps:
        - setWeight: 10
        - pause:
            duration: 1h # 1 hour
        - setWeight: 20
        - pause: {} # pause indefinitely</code></pre>
<p>&nbsp;</p>
<ul>
  <li>argo rollout will create a new rs with a specific number of pods according to the weight and reduce this number of pods form the old rs</li>
</ul>
<pre><code class="language-plaintext">k get rs -n canary
NAME                     DESIRED   CURRENT   READY   AGE
app-rollout-6f44c5f47b   2         2         2       35s
app-rollout-76f479c6bf   8         8         8       21m
</code></pre>
<h6>Progressive Delivery</h6>
<ul>
  <li>Gradually rollouts features to users &nbsp;while minimizing the risk through automated validations. Utilize canary releases, feature flags, and traffic shifting</li>
  <li>Allows controlled exposure of new feature to subset of users while continuously monitoring for issues.<ul>
      <li>canary releases: allows monitoring of the performance and error rates before full deployments with full rollback capabilities</li>
      <li>feature flags: &nbsp;conditional logic to enable or disable features at the run time without code redeployment . It enables controlled feature releases and instant rollback by toggling flags through configuration</li>
      <li>traffic shifting: A/B testing between different versions to compare performance.</li>
      <li>Traffic Mirroring: &nbsp;duplicate the production traffic &nbsp;to test the new version without affecting the users. The shadow &nbsp;version process the requests &nbsp;but responses are discarded</li>
    </ul>
  </li>
</ul>
<h3>Manifest Format and Packaging</h3>
<ol>
  <li>&nbsp;Raws kubernetes yaml ifles</li>
  <li>Kustomize</li>
  <li>Helm</li>
  <li>Combine them&nbsp;</li>
</ol>
<h3>State Store Systems</h3>
<ul>
  <li>centralized repos to save all the desired state definition files&nbsp;<ul>
      <li>Git</li>
      <li>OCI<ul>
          <li>OCI Artifacts: (Open Container Initiative Artifacts ) Package and store all the common k8s formats in one place like docker hub</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<figure class="image"><img src="/oci.png"></figure>
<p>&nbsp;</p>
<h3>Dora Metrics for GitOps</h3>
<ul>
  <li>&nbsp;Industry-standard benchmarks from DORA group used to measure software delivery and operational performance&nbsp;</li>
</ul>
<blockquote>
  <p>DORA group &nbsp;can refer to several distinct entities, most commonly <strong>DevOps Research and Assessment (DORA)</strong>, a team known for software performance research</p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
