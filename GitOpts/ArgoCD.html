<!--
title: Concepts
description: 
published: true
date: 2026-01-11T13:39:36.900Z
tags: 
editor: ckeditor
dateCreated: 2025-12-29T09:23:18.217Z
-->

<h1>What is GitOps</h1>
<ul>
  <li>Without GitOps, operations that are done manually in clusters will lead to a configuration drift, which could lead to down time in the service.</li>
</ul>
<blockquote>
  <p>managing infra and apps using Git as the single source of truth for declarative configuration, with automated reconciliation.</p>
</blockquote>
<ul>
  <li>GitOps is a framework where the entire code deliver process is controlled by git allowing to do rollbacks, operations, and releases seamlessly</li>
  <li>It extends the IaCs to use Git as a control system with the source code of the applications</li>
  <li>GitOps operator like ArgoCD continuously compare the actual state to the state exist in Git</li>
  <li>Reduce the risk of allowing builder tools to have access to the clusters by using pull based deployment.</li>
</ul>
<h4>Principles&nbsp;</h4>
<ol>
  <li>Declarative vs imperative.</li>
  <li>Git as source of the truth</li>
  <li>Software agents (GitOps operators) pull the state from Git and apply it to the target platform</li>
  <li>Reconciliation loops for self-healing (observe-diff-act)</li>
</ol>
<h3>Terms</h3>
<ul>
  <li>Continuous: ongoing process to ensure that the system is in its desired state</li>
  <li>Declarative, Desired state, Actual state for well defined unified configuration and prevent <mark class="marker-yellow">state drift&nbsp;</mark></li>
</ul>
<figure class="image"><img src="/state.png"></figure>
<ul>
  <li>Self-healing to correct the deviation &nbsp;in <mark class="marker-yellow">GitOps Managed Software System</mark></li>
  <li>State store &gt; GIT and OCI (open container initiative )</li>
  <li>Feedback Loops: The process of observing the actual state of the system by collecting logs, metrics, and alerts data that is analyzed and use this information to improve the desired state.</li>
</ul>
<figure class="image"><img src="/loop.png"></figure>
<ul>
  <li>Rollback: manual or automatic fall back to functional state</li>
</ul>
<h4>DevOps vs GitOps</h4>
<ul>
  <li>DevOps works with any application, but GitOps works best with containerized applications. DevOps push the changes to the target platform unlike the GitOps operator that usually &nbsp;pulls the state.</li>
  <li>GitOps usually has two repos &nbsp;one for source code and another for the IaC files.</li>
  <li>The DevOps pipeline will build the container image, pulls the manifests from the IaC repo, and then it modified the manifests with the tag of the created image and push the modified files to the Iac repo.</li>
  <li>The GitOps operator will pull the state from the IaC repo and apply them to the target platform.</li>
</ul>
<figure class="image"><img src="/argo.png"></figure>
<ul>
  <li><mark class="marker-yellow">challenges with secret management in the GitOps</mark></li>
</ul>
<h3>GitOps Reconciler types</h3>
<ol>
  <li>In-Cluster: Runs on the target cluster and use the l<mark class="marker-yellow">ocal API service and pulls the state</mark>. Do not require exposing the API server outside the cluster<ul>
      <li>Argocd can act as both types, and must explicitly configured to connect to the external clusters.</li>
    </ul>
  </li>
  <li>External: &nbsp;The Operator connect to the external API-Server to<mark class="marker-yellow"> push stateto the target the clusters</mark>, which might introduces security risks</li>
</ol>
<h4>Well known tools</h4>
<ul>
  <li>ArgoCD</li>
  <li>FluxCD</li>
  <li>Atlantis for terraform</li>
  <li>Helm operator</li>
  <li>ignite for vitraul machines management</li>
</ul>
<figure class="image"><img src="/tools.png"></figure>
<h1>ArgoCD</h1>
<ul>
  <li>It works with kustomize, Helm charts, ksonnet applications, Jsonnet files, Yaml / Json manfiests</li>
  <li>Integrates with SSO solutions</li>
  <li>Audit trails for application events and API calls</li>
  <li>WebHook integration with Git servers</li>
  <li>Detect configuration drift</li>
  <li>Prometheus metrics</li>
  <li>expose gRPC REST APIs</li>
</ul>
<figure class="image"><img src="/archee.png"></figure>
<h3>Core Components&nbsp;</h3>
<ul>
  <li>argocd-server: gRPC/Rest API server that exposed the APIs to the UI/CLI/CICD systems.<ul>
      <li>Manages Applications and credentials</li>
      <li>Invokes operations like sync and rollback</li>
      <li>Handles authentication and RBAC by delegating authentication to the argocd-dex-server that integrates with different IdPs</li>
    </ul>
  </li>
  <li>argocd-redis: for caching only</li>
  <li>argocd-repo-server:<ul>
      <li>handles retrieving the files from repos servers</li>
      <li>generate the final manifests</li>
      <li>Run the sidecar plugins</li>
    </ul>
  </li>
  <li>argocd-application-controller<ul>
      <li>handles the reconciliation process</li>
    </ul>
  </li>
  <li>argocd-notification-controller<ul>
      <li>Alerts and notification</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>All the core components expose promethues metrics&nbsp;</p>
</blockquote>
<h4>Terminology</h4>
<ul>
  <li>Applications: is a crd that create when ArgoCd is deployed, and groups some kubernetes resources defined by a manifest</li>
  <li>Application source type: The tool that is used to build the applications (helm, kustomize…)</li>
  <li>Project: logical grouping of applications</li>
  <li>States:<ul>
      <li>Target state: &nbsp;the desired state</li>
      <li>Live state: &nbsp;the actual one</li>
    </ul>
  </li>
  <li>Sync terms:<ul>
      <li>sync status: Does the target state matches the live state?</li>
      <li>sync: the process of making an application move to its target state</li>
      <li>sync operation status: &nbsp;whether the sync succeeded or not</li>
    </ul>
  </li>
  <li>Refresh: compares the target with the live</li>
  <li>Health: &nbsp;the application is up and running?</li>
  <li>Continues reconciliation == auto sync</li>
</ul>
<h3>Installation options</h3>
<ol>
  <li>core: &nbsp;minimal installation no api-server and UI</li>
  <li>Multi-Tenant:<ol>
      <li>HA: &nbsp;for Production, ha/install.yaml and ha/namespace-install.yaml</li>
      <li>Non HA: &nbsp;for POC, install.yaml cluster admin access and namespace-install.yaml for access to only one namespace.</li>
    </ol>
  </li>
</ol>
<h3>Installation</h3>
<ul>
  <li><a href="https://github.com/argoproj/argo-cd/releases">Releases · argoproj/argo-cd · GitHub</a></li>
</ul>
<pre><code class="language-plaintext">kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v3.2.3/manifests/install.yaml</code></pre>
<p>&nbsp;</p>
<ul>
  <li>install the argocd cli from the assets section in the release page</li>
  <li>the initial admin secret is saved in a secret called <mark class="marker-yellow">argocd-initial-admin-secret</mark></li>
</ul>
<h4>Apps and projects</h4>
<ul>
  <li>Application is a crd that define<ul>
      <li>source: repoURL, targetRevision, Path</li>
      <li>destination: target cluster, namespace</li>
      <li>project names it belongs to</li>
      <li>sync policy</li>
      <li>ignore diff</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
 name: guestbook
 namespace: argocd
spec:
 project: default
 source:
   repoURL: https://github.com/argoproj/argocd-example-apps.git
   targetRevision: HEAD
   path: guestbook
 destination:
   server: https://kubernetes.default.svc
   namespace: guestbook</code></pre>
<p>&nbsp;</p>
<ul>
  <li>argocd create k8s secrets with git server credentials</li>
  <li>To create application using cli</li>
</ul>
<pre><code class="language-plaintext">argocd app create name --repo --path --dest-namespace --dest-server https://kubernetes.default.svc</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To sync</li>
</ul>
<pre><code class="language-plaintext">argocd app sync name</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To create projects</li>
</ul>
<pre><code class="language-plaintext">argocd proj create -h</code></pre>
<p>&nbsp;</p>
<ul>
  <li>projects include state stores, target clusters, roles , resource white list, and a sync window<ul>
      <li>resource white list includes which k8s resources can be deployed in this project</li>
      <li>sync windows: in which time the sync is allowed or blocked</li>
    </ul>
  </li>
</ul>
<h3>Deployment strategies&nbsp;</h3>
<ol>
  <li>RollingUpdate: Replaces pods one by one after becoming ready ( default )</li>
  <li>Recreate: Terminate and create</li>
  <li>Blue Green: Two deployments Blue is active (current version) &nbsp;and green which is idle (new version). The traffic is switched from blue to green once the green deployment is validated<ul>
      <li>Needs two identical deployments</li>
    </ul>
  </li>
  <li>Canary deployment: &nbsp;gradual rollouts &nbsp;Releases new features to a small subset of users before expanding to the entire user base.<ul>
      <li>Needs two deployments and optional service mesh</li>
    </ul>
  </li>
</ol>
<h3>Argo Rollouts</h3>
<ul>
  <li>A controller and set of CRDs that support advanced deployment strategies, fine grade traffic control, automatic analysis, and rollback capabilities. ( integrates with service mesh and ingress controllers )</li>
</ul>
<h6>Installation</h6>
<ul>
  <li>Cluster wide installation or name spaced installation&nbsp;</li>
</ul>
<pre><code class="language-plaintext">kubectl create namespace argo-rollouts
kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/download/v1.8.3/install.yaml</code></pre>
<p>Download the cli from the release pages</p>
<pre><code class="language-plaintext">curl -LO https://github.com/argoproj/argo-rollouts/releases/download/v1.8.3/kubectl-argo-rollouts-linux-amd64
chmod +x kubectl-argo-rollouts-linux-amd64
sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To show the UI</li>
</ul>
<pre><code class="language-plaintext">kubectl-argo-rollouts dashboard</code></pre>
<h6>Architecture</h6>
<ul>
  <li>Rollout Controller:&nbsp;<ul>
      <li>controls the rollout resource lifecycle by creating the replicaSets and integrates with ingress controllers to split or redirect &nbsp;the traffic&nbsp;</li>
      <li>Controlled promotion&nbsp;</li>
    </ul>
  </li>
  <li>AnalysisTemplate Controller:&nbsp;<ul>
      <li>Trigger AnalysisRuns to collect metrics to analysis the deployment performance&nbsp;</li>
    </ul>
  </li>
</ul>
<h3>Converting deployment to rollout</h3>
<ol>
  <li>Directing conversion: change the kind and API then add strategy section</li>
  <li>WorkloadRef Method:<ul>
      <li>create standard deployment&nbsp;</li>
      <li>add the deployment to the rollout using workloadRef attribute&nbsp;</li>
      <li>Integrate with existing tools that only use deployment object</li>
      <li>decouple deployment from update strategy&nbsp;</li>
    </ul>
  </li>
</ol>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: test
spec:
 replicas: 4
 workloadRef:
   apiVersion: apps/v1
   kind: Deployment
   name: test-deploy
   scaleDown: never | onsuccess | progessive
 strategy:
   blueGreen:
     activeService: svc-act
     previewService: svc-dev
     autoPromotionEnabled: false</code></pre>
<p>&nbsp;</p>
<h6>Blue Green deployment with argo-rollout&nbsp;</h6>
<ul>
  <li>argo rollout manage<mark class="marker-yellow"> RepliaSets and services</mark> ( active and preview in the same namespace)</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: rollout-bluegreen
spec:
  replicas: 2
  revisionHistoryLimit: 2
  selector:
    matchLabels:
      app: rollout-bluegreen
  template:
    metadata:
      labels:
        app: rollout-bluegreen
    spec:
      containers:
      - name: rollouts-demo
        image: argoproj/rollouts-demo:blue
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
  strategy:
    blueGreen: 
      # activeService specifies the service to update with the new template hash at time of promotion.
      # This field is mandatory for the blueGreen update strategy.
      activeService: rollout-bluegreen-active
      # previewService specifies the service to update with the new template hash before promotion.
      # This allows the preview stack to be reachable without serving production traffic.
      # This field is optional.
      previewService: rollout-bluegreen-preview
      # autoPromotionEnabled disables automated promotion of the new stack by pausing the rollout
      # immediately before the promotion. If omitted, the default behavior is to promote the new
      # stack as soon as the ReplicaSet are completely ready/available.
      # Rollouts can be resumed using: `kubectl argo rollouts promote ROLLOUT`
      autoPromotionEnabled: false</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Both services use the same parameters expect the service names. In case of a rollout, the preview service will be used to handle the traffic of the new deployment by introduction a hash label to both the pods in the new deployment and the service selector</li>
</ul>
<pre><code class="language-plaintext">k get svc -n blue-green -o yaml
apiVersion: v1
items:
- apiVersion: v1
  kind: Service
  metadata:
    name: highway-bluegreen-active
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30838
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: 674c49d44d   &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort

- apiVersion: v1
  kind: Service
  metadata:
    name: highway-bluegreen-preview
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30168
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9   &gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">k get rs -n blue-green -o yaml
apiVersion: v1
items:
- apiVersion: apps/v1
  kind: ReplicaSet
  metadata:


    labels:
      app: highway-bluegreen
      rollouts-pod-template-hash: 674c49d44d       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    name: highway-bluegreen-674c49d44d
    namespace: blue-green
    ownerReferences:
    - apiVersion: argoproj.io/v1alpha1
      blockOwnerDeletion: true
      controller: true
      kind: Rollout
      name: highway-bluegreen

  spec:

    selector:

      matchLabels:
        app: highway-bluegreen
        rollouts-pod-template-hash: 674c49d44d  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    template:
      metadata:

        labels:
          app: highway-bluegreen
          rollouts-pod-template-hash: 674c49d44d  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

.......
- apiVersion: apps/v1
  kind: ReplicaSet
  metadata:

    labels:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    name: highway-bluegreen-d88b957f9
    namespace: blue-green
    ownerReferences:
    - apiVersion: argoproj.io/v1alpha1
      blockOwnerDeletion: true
      controller: true
      kind: Rollout
      name: highway-bluegreen

  spec:

    selector:
      matchLabels:
        app: highway-bluegreen
        rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here
    template:
      metadata:

        labels:
          app: highway-bluegreen
          rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here





</code></pre>
<ul>
  <li>To &nbsp;route the traffic to the newer version manually promote the preview version. Then argo rollouts will change the labels on the active service to adopt the new version pods and reduce the older replicaset version to zero replicas.</li>
</ul>
<pre><code class="language-plaintext">
- apiVersion: v1
  kind: Service
  metadata:

    name: highway-bluegreen-active
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30838
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort

- apiVersion: v1
  kind: Service
  metadata:

    name: highway-bluegreen-preview
    namespace: blue-green

  spec:

    ports:
    - nodePort: 30168
      port: 3000
      protocol: TCP
      targetPort: 3000
    selector:
      app: highway-bluegreen
      rollouts-pod-template-hash: d88b957f9 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; here

    type: NodePort
</code></pre>
<ul>
  <li>If you want to rollback use the dashboard or cli</li>
</ul>
<h6>Canary deployment</h6>
<ul>
  <li>Gradual rollout to eventually reach 100% of the new version by certain rate.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: example-rollout
spec:
  replicas: 10
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.15.4
          ports:
            - containerPort: 80
  minReadySeconds: 30
  revisionHistoryLimit: 3
  strategy:
    canary: #Indicates that the rollout should use the Canary strategy
      maxSurge: '25%'
      maxUnavailable: 0
      steps:
        - setWeight: 10
        - pause:
            duration: 1h # 1 hour
        - setWeight: 20
        - pause: {} # pause indefinitely</code></pre>
<p>&nbsp;</p>
<ul>
  <li>argo rollout will create a new rs with a specific number of pods according to the weight and reduce this number of pods form the old rs</li>
</ul>
<pre><code class="language-plaintext">k get rs -n canary
NAME                     DESIRED   CURRENT   READY   AGE
app-rollout-6f44c5f47b   2         2         2       35s
app-rollout-76f479c6bf   8         8         8       21m
</code></pre>
<h6>Progressive Delivery</h6>
<ul>
  <li>Gradually rollouts features to users &nbsp;while minimizing the risk through automated validations. Utilize canary releases, feature flags, and traffic shifting</li>
  <li>Allows controlled exposure of new feature to subset of users while continuously monitoring for issues.<ul>
      <li>canary releases: allows monitoring of the performance and error rates before full deployments with full rollback capabilities</li>
      <li>feature flags: &nbsp;conditional logic to enable or disable features at the run time without code redeployment . It enables controlled feature releases and instant rollback by toggling flags through configuration</li>
      <li>traffic shifting: A/B testing between different versions to compare performance.</li>
      <li>Traffic Mirroring: &nbsp;duplicate the production traffic &nbsp;to test the new version without affecting the users. The shadow &nbsp;version process the requests &nbsp;but responses are discarded</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>An e-commerce company wants to test a new checkout feature with 5% of its live user traffic before rolling it out to everyone. The GitOps pipeline deploys the new version alongside the old one and configures a service mesh to split traffic accordingly. Which progressive delivery pattern is this?</p>
  <p><strong>Correct Answer(Canary Release):</strong> A Canary Release is a pattern where a new version is released to a small subset of the production environment. Its performance and stability are monitored with live traffic before a decision is made to roll it out more widely or roll it back.</p>
  <p><strong>Wrong Answer(A/B Testing)</strong>: A/B testing is similar but is typically focused on comparing user behavior between two versions to make a business decision (e.g., which button color converts better), whereas a canary is focused on technical stability and performance. The scenario leans more towards technical validation.</p>
</blockquote>
<h3>Manifest Format and Packaging</h3>
<ol>
  <li>Raws kubernetes yaml ifles</li>
  <li>Kustomize</li>
  <li>Helm</li>
  <li>Combine them</li>
</ol>
<h3>State Store Systems</h3>
<ul>
  <li>centralized repos to save all the desired state definition files<ul>
      <li>Git</li>
      <li>OCI<ul>
          <li>OCI Artifacts: (Open Container Initiative Artifacts ) Package and store all the common k8s formats in one place like docker hub</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<figure class="image"><img src="/oci.png"></figure>
<p>&nbsp;</p>
<h3>Dora Metrics for GitOps</h3>
<ul>
  <li>Industry-standard benchmarks from DORA group used to measure software delivery and operational performance</li>
</ul>
<blockquote>
  <p>DORA group &nbsp;can refer to several distinct entities, most commonly <strong>DevOps Research and Assessment (DORA)</strong>, a team known for software performance research</p>
</blockquote>
<ul>
  <li>Core:<ol>
      <li>Deployment frequency</li>
      <li>Lead time for changes</li>
      <li>Change failure rate</li>
      <li>Time to restore service</li>
    </ol>
  </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
