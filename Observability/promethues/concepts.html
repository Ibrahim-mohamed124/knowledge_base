<!--
title: Concepts
description: 
published: true
date: 2026-02-06T06:47:50.832Z
tags: 
editor: ckeditor
dateCreated: 2026-01-19T11:20:24.899Z
-->

<h1>Intro to Observability</h1>
<ul>
  <li>The ability to understand and measure the state of a system based upon data generated by the system</li>
  <li>It allows to generate actionable outputs from unexpected scenarios in dynamic environments and help in<ul>
      <li>Better insights into the internal working of a system</li>
      <li>speed up troubleshooting</li>
      <li>Monitor performance</li>
    </ul>
  </li>
  <li>Unlike monolithic application microservices applications are much more complex</li>
  <li>it gives us answers for<ul>
      <li>error rates</li>
      <li>high latency</li>
      <li>timing outs</li>
    </ul>
  </li>
</ul>
<h3>Pillars of Observability</h3>
<ol>
  <li>logging:<ul>
      <li>Records of events that have occurred and encapsulated information about the specific event with timestamps</li>
    </ul>
  </li>
  <li>metrics:<ul>
      <li>numeric data about the system that contain:<ul>
          <li>Metric name</li>
          <li>Value of the metric</li>
          <li>Timestamp</li>
          <li>Dimensions: more data about the mertic</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Traces:<ul>
      <li>allow to follow operations as they traverses through various systems &amp; services hop by hop to understand the whole picture<ul>
          <li>trace ID: the unique id for a trace</li>
          <li>Spans: evens in the trace and contain start time of the span, duration, and parent id</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
<h3>Quality of Service indicators</h3>
<ol>
  <li>measurable targets/goals to help organizations strike the right balance between product development and operations work.<ul>
      <li>SLI: service level indicator is a quantitative measure of some aspect of the level of service that is provided like request latency, error rate, saturation, throughput, and availability.<ul>
          <li>Metrics that accurately measure the user's experience.</li>
        </ul>
      </li>
      <li>SLO: service level objective - target value or range &nbsp;of an SLI</li>
      <li>SLA: service level agreement: &nbsp;Contract between end user and provider to meet the SLO</li>
    </ul>
  </li>
</ol>
<h2>Prometheus</h2>
<h3>Use cases</h3>
<ul>
  <li>collect metrics from many datacenters</li>
  <li>alerting when conditions are met</li>
  <li>scrape and do operations in metrics.</li>
  <li>data charting</li>
</ul>
<h3>Basics</h3>
<ul>
  <li>Prometheus collects metrics by scraping targets who expose metrics through an HTTP endpoint</li>
  <li>Store the scraped metrics into time based database</li>
</ul>
<h6>Architecture</h6>
<ol>
  <li>Data retrieval workers: &nbsp;scrape the data from the target endpoints by sending http requests ( pulling metrics )</li>
  <li>TSDB: &nbsp;stores the metric data</li>
  <li>HTTP server: accepts PromeQL Query</li>
  <li>Exporters: runs on the targets so data retrieval can scrape the metrics</li>
  <li>Push Gateway: for short lived jobs that cannot wait till the data retrievals pull the metrics so the gateway pushes stores the metrics till the data retrieval workers pull the data</li>
  <li>Service Discovery: Dynamically update the list of target to monitor</li>
  <li>Alert manager: to send alerts</li>
</ol>
<figure class="image"><img src="/observability/arch.png"></figure>
<p>&nbsp;</p>
<h6>Collecting Metrics</h6>
<ul>
  <li>Prometheus collects metrics by sending http requests to /metrics endpoint of each target by default</li>
  <li>If the system has no metrics endpoint use exporter process to collect metrics and exposing /metrics endpoint</li>
  <li>client libraries allow to expose any application metrics for promethues for different languages like go and python</li>
</ul>
<p>&nbsp;</p>
<blockquote>
  <p>In Prometheus version 3.5.0 and above, the <code>consoles/</code> and <code>console_libraries/</code> directories have been removed from the distribution tarball.</p>
</blockquote>
<h3>Installation as systemd services</h3>
<ul>
  <li>Install the binary from the official docs</li>
</ul>
<pre><code class="language-plaintext">wget https://github.com/prometheus/prometheus/releases/download/v3.9.1/prometheus-3.9.1.linux-amd64.tar.gz</code></pre>
<p>&nbsp;</p>
<ul>
  <li>unarchive the tar file</li>
</ul>
<pre><code class="language-plaintext"> tar -xvaf prometheus-3.9.1.linux-amd64.tar.gz</code></pre>
<p>&nbsp;</p>
<ul>
  <li>create a user for prometheus without a login shell</li>
</ul>
<pre><code class="language-plaintext">useradd -no-create-home --shell /bin/false prometheus</code></pre>
<p>&nbsp;</p>
<ul>
  <li>make the configuration and data directories</li>
</ul>
<pre><code class="language-plaintext">mkdir /etc/prometheus &amp;&amp; mkdir /var/lib/prometheus
chown prometheus:prometheus /etc/prometheus &amp;&amp; chown prometheus:promethues /var/lib/promethues</code></pre>
<p>&nbsp;</p>
<ul>
  <li>move prometheus and promtool binaries &nbsp;to /usr/local/bin/ and change ownership</li>
</ul>
<pre><code class="language-plaintext">mv prometheus promtool /usr/local/bin/ &amp;&amp; chown prometheus:prometheus /usr/local/bin/prometheus /usr/local/bin/promtool</code></pre>
<p>&nbsp;</p>
<ul>
  <li>move prometheus.yaml to /etc/prometheus/ and change ownership</li>
  <li>create the service file</li>
</ul>
<pre><code class="language-plaintext">[Unit]
Description=Prometheus
Wants=network-online.target
After=network-online.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/prometheus \
   --config.file /etc/prometheus/prometheus.yml \
   --storage.tsdb.path /var/lib/prometheus/     \

[Install]
WantedBy=multi-user.target</code></pre>
<p>&nbsp;</p>
<ul>
  <li>copy the file to the /etc/systemd/system/promethues.service and enable the service</li>
</ul>
<h3>Install the node exporter as a systemd</h3>
<ul>
  <li>get the binary and unarchieve</li>
</ul>
<pre><code class="language-plaintext">https://github.com/prometheus/node_exporter/releases/download/v1.10.2/node_exporter-1.10.2.linux-amd64.tar.gz</code></pre>
<p>&nbsp;</p>
<ul>
  <li>create a user and move the binary to /etc/local/bin then change ownership</li>
  <li>create the systemd service</li>
</ul>
<pre><code class="language-plaintext">[Unit]
Description=Node Exporter
Wants=network-online.target
After=network-online.target
[Service]
User=node_exporter
Group=node_exporter
Type=simple
ExecStart=/usr/local/bin/node_exporter
[Install]
WantedBy=multi-user.target</code></pre>
<h3>config prometheus</h3>
<ul>
  <li>configure the prometheus by editing the prometheus.yaml file</li>
</ul>
<pre><code class="language-plaintext">global:
  scrape_interval:     15s # By default, scrape targets every 15 seconds.

  # Attach these labels to any time series or alerts when communicating with
  # external systems (federation, remote storage, Alertmanager).
  external_labels:
    monitor: 'codelab-monitor'

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.
  - job_name: 'prometheus'

    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 5s

    static_configs:
      - targets: ['localhost:9090']
  - job_name: "nodes"
    scrape_interval: 20s
    sample_limit: 1000
    scheme: http
    metrics_path: /metrics
    static_configs:
    - targets: [10.200.130.134:9100, 10.200.130.142:9100, 10.200.130.197:9100]
</code></pre>
<h3>Authentication and Encryption</h3>
<ul>
  <li>config.yaml customize node<i>exporter configurations in /etc/node_exporter with the crt and key</i></li>
</ul>
<pre><code class="language-plaintext">tls_server_config:
  cert_file: file.crt
  key_file: file.key</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">chown -R node_exporter:node_exporter /etc/node_exporter/</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">./node_exporter   --web.config.file="/etc/node_exporter/config.yml"</code></pre>
<p>&nbsp;</p>
<ul>
  <li>update prometheus.yaml file and restart the service</li>
</ul>
<pre><code class="language-plaintext">  - job_name: "nodes"
    scrape_interval: 20s
    scheme: https
    tls_config:
      ca_file: /etc/prometheus/MY-ORG.crt
      insecure_skip_verify: false
    metrics_path: /metrics
    static_configs:
    - targets: [10.200.130.134:9100, 10.200.130.142:9100, 10.200.130.197:9100]</code></pre>
<p>&nbsp;</p>
<h3>Authentication</h3>
<ul>
  <li>use any tool to create a hashed password like apach2-utils or httpd-tools</li>
</ul>
<pre><code class="language-plaintext">htpasswd -nBC 10 "" | tr -d ':\n'; echo</code></pre>
<p>&nbsp;</p>
<ul>
  <li>add the config</li>
</ul>
<pre><code class="language-plaintext">vi /etc/node_exporter/config.yml
basic_auth_users:
  prometheus: &lt;hashed-password&gt;</code></pre>
<p>&nbsp;</p>
<ul>
  <li>config prometheus</li>
</ul>
<pre><code class="language-plaintext">vi /etc/prometheus/prometheus.yml
- job_name: "node"
  scheme: https
  basic_auth:
   username: prometheus
   password: secret-password-plain-text</code></pre>
<h3>Metrics</h3>
<ul>
  <li>the metric has standard structure</li>
</ul>
<pre><code class="language-plaintext">&lt;metric_name&gt;{comma seperated list of labels}&lt;value&gt;&lt;timestap&gt;</code></pre>
<p>&nbsp;* &nbsp;The labels are the instances of a metric like a class and instance of that class in programming</p>
<p>&nbsp;* Every metrics has two labels by default (instance, job)</p>
<pre><code class="language-plaintext">the metric name is save under the __name__ label inside the prometheus server</code></pre>
<p>&nbsp;</p>
<ul>
  <li>the metrics are stored with timestamp using the Unix Epoch time</li>
  <li>promethues stores these metrics with unique set of labels and name in a time series</li>
  <li>Every metric has two attributes<ol>
      <li>Type: &nbsp;specify the type of that metric</li>
      <li>Help: description of what is that metric</li>
    </ol>
  </li>
</ul>
<h6>Types of metrics</h6>
<ul>
  <li>Counter<ul>
      <li>how many times an event happened like total number of &nbsp;http requests</li>
    </ul>
  </li>
  <li>Gauge<ul>
      <li>measure the current value of event, can go up or down like current CPU utilization</li>
    </ul>
  </li>
  <li>Histogram<ul>
      <li>groups &nbsp;metrics for in certain limits(quantiles), how many total events in a period of time like request size and response time</li>
    </ul>
  </li>
  <li>Summary<ul>
      <li>like histogram but does not need quantiles ahead of time like percentages of response time for a number of requests</li>
    </ul>
  </li>
</ul>
<h3>Promtools</h3>
<ul>
  <li>Check and validate configuration<ul>
      <li>validate prometheus.yaml</li>
      <li>validate rules files</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">[root@k8s-master ~]# promtool check config /etc/prometheus/prometheus.yml
Checking /etc/prometheus/prometheus.yml
 SUCCESS: /etc/prometheus/prometheus.yml is valid prometheus config file syntax

</code></pre>
<ul>
  <li>Validate metrics passed to it are correctly formatted</li>
  <li>Can perform queries on a promethues server</li>
  <li>Debugging &amp; Profiling a promethues server</li>
  <li>Perform unit tests against recording and alerting rules</li>
</ul>
<h3>scraping metrics from containers</h3>
<ul>
  <li>Docker Engine Metrics and cAdvisor provide the /metrics endpoint</li>
  <li>To enable Docker Engine Metrics<ul>
      <li>create a file /etc/docker/daemon.json with that content</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">{
  "metrics-addr" : "127.0.0.1:9323",
  "experimental" : true
}</code></pre>
<p>&nbsp; &nbsp; &nbsp;* restart docker service&nbsp;</p>
<ul>
  <li>Or use this with containerd &nbsp;/etc/containerd/config.toml</li>
</ul>
<pre><code class="language-plaintext">[metrics]

  address = '0.0.0.0:1338'
  grpc_histogram = true
</code></pre>
<ul>
  <li>to get the container level metrics cAdvisor must be installed</li>
</ul>
<h6>root@prometheus-server ~ ➜ &nbsp;cat docker-compose.yml&nbsp;<br>version: '3.4'<br>services:<br>&nbsp; cadvisor:<br>&nbsp; &nbsp; image: gcr.io/cadvisor/cadvisor<br>&nbsp; &nbsp; container_name: cadvisor<br>&nbsp; &nbsp; privileged: true<br>&nbsp; &nbsp; devices:<br>&nbsp; &nbsp; &nbsp; - "/dev/kmsg:/dev/kmsg"<br>&nbsp; &nbsp; volumes:<br>&nbsp; &nbsp; &nbsp; - /:/rootfs:ro<br>&nbsp; &nbsp; &nbsp; - /var/run:/var/run:ro<br>&nbsp; &nbsp; &nbsp; - /sys:/sys:ro<br>&nbsp; &nbsp; &nbsp; - /var/lib/docker/:/var/lib/docker:ro<br>&nbsp; &nbsp; &nbsp; - /dev/disk/:/dev/disk:ro<br>&nbsp; &nbsp; ports:<br>&nbsp; &nbsp; &nbsp; - 8070:8080</h6>
<h3>PromeQL</h3>
<ul>
  <li>query language in promethues</li>
</ul>
<h6>PromQL data types</h6>
<ol>
  <li>String &gt; simple string value</li>
  <li>scalar &gt; numeric floating value</li>
  <li>Instant Vector &gt; a set of time series with a single sample for each time series, all sharing the same timestamp<ul>
      <li>like querying node-cpu-seconds-total will return a number of timeseries' (metric + unique labels) for each cpu. all the returned values share the same timestamp</li>
    </ul>
  </li>
  <li>Range Vector &gt; set of time series with a range of different data points over time for each time series<ul>
      <li>like querying node-cpu-seconds-total{selectors}<mark class="marker-yellow">[xm]</mark>. The data that will be returned will cover a range of x mintues</li>
    </ul>
  </li>
</ol>
<h6>Selector &amp; Matchers</h6>
<ul>
  <li>to select only a subset of timeseries' of a metric</li>
  <li>types of matchers<ul>
      <li>equality = &nbsp;&gt; node-filesystem-avail-bytes{instance="node1"}</li>
      <li>negative equality ≠ node-filesystem-avail-bytes{instance="node1, device!≠"tmpfs"}</li>
      <li>regular expression =~ node-filesystem-avail-bytes{device=~"/dev/sda.*}</li>
      <li>negative regex !~ node-filesystem-avail-bytes{mountpoint!~"/boot".*}</li>
    </ul>
  </li>
</ul>
<h6>offset modifier&nbsp;</h6>
<ul>
  <li>instead of getting the latest value, get a value from the history</li>
  <li>metric{selector} offset xU &gt;&gt; unit cloud be days, weeks, hours, minutes</li>
  <li>to go back to specific point in time use @ with unix timestamp<ul>
      <li>node-memeory-active-bytes{} @34305753 offset 4m</li>
    </ul>
  </li>
</ul>
<p>&nbsp;</p>
