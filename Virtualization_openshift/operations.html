<!--
title: Chapter 2.  Running and Accessing Virtual Machines
description: 
published: true
date: 2025-11-17T14:16:02.062Z
tags: 
editor: ckeditor
dateCreated: 2025-11-17T13:40:32.886Z
-->

<h2>Virtual Machine Resources</h2>
<ul>
  <li>VM object specifies a template to create a running instance of the VM inside your cluster. The <mark class="marker-yellow">running instance of a VM is a </mark><i><mark class="marker-yellow">Virtual Machine Instance (VMI)</mark></i>. A container inside a pod executes and manages the VMI.</li>
  <li>A VM object specifies the template for a VMI pod.</li>
  <li>If a VMI is deleted, then<mark class="marker-yellow"> Kubernetes generates another instance that is based on the VM object configuration.</mark></li>
</ul>
<blockquote>
  <p>When a VM is created and started, a <code>virt-controller</code> pod signals to a <code>virt-handler</code> pod on a cluster node to create a <code>virt-launcher</code> pod for the VMI. The <code>virt-launcher</code> pod consists of a running <code>libvirtd</code> container instance to execute the VMI as an isolated process.</p>
</blockquote>
<h3>Components of an OpenShift Virtual Machine</h3>
<h4>Virtual Machine Consoles</h4>
<ul>
  <li><strong>VNC Console: </strong>The VNC console provides both text-based and graphical consoles, depending on the configuration of the VMI's operating system.</li>
  <li><strong>Serial Console: </strong>The <i>serial console</i> connects you to the VMI's text-based console through its serial port.</li>
  <li><strong>RDP Console: </strong>The <i>Quick Emulator</i> (QEMU) guest agent must be installed and running on the VMI to use the RDP console.</li>
</ul>
<h4>Network Interfaces</h4>
<ul>
  <li><strong>Default Pod Network:</strong>
    <ul>
      <li>The <i>default pod network</i> assigns an IP address to the VMI from the cluster's pod network.</li>
      <li>Network interface must use the masquerade binding method.</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>Masquerade binding connects the<mark class="marker-yellow"> guest NIC to the Pod’s network namespace through a Linux bridge and a tap device</mark>, then applies Network Address Translation so the guest’s IP traffic is translated to the Pod IP that the cluster CNI understands. That NAT step is what lets the rest of the cluster (other pods, services, CNI routing) treat the VMI as a pod endpoint and reach it using cluster networking semantics</p>
</blockquote>
<ul>
  <li><strong>Multus:</strong>
    <ul>
      <li>Multus provides a <i>Custom Resource Definition</i> (CRD), which is called a <i>Network Attachment Definition</i> (NAD), to enable you to connect pods, VMs, or VMIs to one or more networks.</li>
    </ul>
  </li>
  <li><strong>Single Root I/O Virtualization:</strong>
    <ul>
      <li>a <i>Single Root I/O Virtualization</i> (SR-IOV) device that enables a VMI to connect to a virtual function network for high performance.</li>
    </ul>
  </li>
</ul>
<h4>Persistent Volumes and Persistent Volume Claims</h4>
<h4>Boot Sources</h4>
<ul>
  <li>A boot source is a fully configured disk image that includes the operating system (OS), drivers, and other initial data for a VM.<ul>
      <li>cloud image in either RAW or QCOW2 format</li>
      <li>installation disk image in ISO format</li>
      <li>container disk from a container image registry</li>
      <li>PVC.</li>
      <li>Base operating system images from container registries, such as Quay.io</li>
    </ul>
  </li>
  <li>Upload a boot source from a local system, use an existing volume, use an existing snapshot, or download the volume from a registry</li>
</ul>
<blockquote>
  <p>The download from a registry creates a <code>dataimportcron</code> resource that defines a cron job to pull and import the disk image.</p>
</blockquote>
<ul>
  <li>The <i>Containerized Data Importer</i> (CDI) imports the golden images from Red&nbsp;Hat to the <code>openshift-virtualization-os-images</code> project as snapshots or PVCs.</li>
</ul>
<h4>Configuration Maps and Secrets</h4>
<ol>
  <li>create a disk to contain the configuration map or the secret.</li>
  <li>After adding the disk with the configuration map or secret, &nbsp;start the VM and mount the disk manually from the VM console.</li>
</ol>
<h3>Components of Virtual Machine Creation</h3>
<blockquote>
  <p><code>libvirtd</code> instance provides a low-level virtualization architecture and interfaces with the kernel to manage the lifecycle of the VM process.</p>
</blockquote>
<ol>
  <li>The <code>virt-controller</code> operator monitors for new VMI objects.</li>
  <li>The <code>virt-handler</code> daemon set runs on each node to execute any necessary actions to meet a VM object's defined state. The <code>virt-handler</code> daemon set monitors for changes in a VM, and creates the <code>virt-launcher</code> container.</li>
  <li>The <code>virt-launcher</code> container runs within each VM's pod and instantiates the VM with the use of a local <code>libvirtd</code> instance.</li>
  <li>the <code>virt-launcher</code> pod routes IPv4 traffic to the<mark class="marker-yellow"> Dynamic Host Configuration Protocol (DHCP) address of the VMI, </mark>This routing enables you to connect to a VMI with a port-forwarding connection(SNAT)</li>
</ol>
<blockquote>
  <p>the DHCP address for the guest is provided by a DHCP server instance that runs inside the virt‑launcher pod (the pod networking layer) and hands out IPs to the guest over the tap/bridge the launcher creates</p>
</blockquote>
<p>&nbsp;</p>
<ul>
  <li>The <code>libvirtd</code> instance also includes the <code>virsh</code> command, to manage VMs. This utility provides several commands to list, start, stop, or reboot VMs, which can be accessed from the virt-launcher pod:<ol>
      <li><code>virsh list</code>: Lists all running VMs.</li>
      <li><code>virsh start</code>: Starts a VM.</li>
      <li><code>virsh shutdown</code>: Shuts down a VM.</li>
      <li><code>virsh dumpxml</code>: Dumps the XML configuration of a VM to STDOUT. You can use it to update an existing VM or use it as a template to create another VM.</li>
      <li><code>virsh reset</code>: Resets a VM without shutting it down previously.</li>
      <li><code>virsh restore</code>: Restores a VM from a saved file.</li>
      <li><code>virsh migrate</code>: Migratesa VM to another host.</li>
      <li><code><strong>virsh event</strong></code> To list all events from a VM</li>
    </ol>
  </li>
</ul>
<p>&nbsp;</p>
<h3>Stand-alone VMIs</h3>
<ul>
  <li>A <i>stand-alone</i> VMI is created independently from the OpenShift Virtualization environment</li>
</ul>
<h3>common ways to create VMs</h3>
<ul>
  <li><strong>Templates:&nbsp;</strong>
    <ul>
      <li>predefined templates to create VMs with default parameters that are provided in the configuration of the available boot source from Red&nbsp;Hat.</li>
      <li>create templates that define these custom settings and boot sources, override any parameters that are defined in the template for the VM.</li>
    </ul>
  </li>
  <li><strong>Instance types:</strong>
    <ul>
      <li>Instance types must define CPU and memory resources. All other attributes are optional.</li>
      <li>Cannot override any parameters that are defined in the instance type.&nbsp;</li>
    </ul>
  </li>
  <li><strong>Declarative files:&nbsp;</strong></li>
</ul>
<pre><code class="language-plaintext">virtctl create vm --name mariadb-prod
apiVersion: kubevirt.io/v1
kind: VirtualMachine
...output omitted...
    spec:
      domain:
        devices: {}
        memory:
          guest: 512Mi
        resources: {}
      terminationGracePeriodSeconds: 180
status: {}</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>Enabling SSH access creates a node port service within the VM's namespace.&nbsp;</p>
</blockquote>
<blockquote>
  <p>Initially, you can create templates only for the existing default operating systems. However, if you install the KubeVirt <code>common-templates</code> package in your OpenShift cluster, then you can create templates for other operating systems, such as Ubuntu or openSUSE.</p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
