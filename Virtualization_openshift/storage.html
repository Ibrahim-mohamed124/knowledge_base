<!--
title: storage
description: 
published: true
date: 2025-11-20T13:48:15.458Z
tags: 
editor: ckeditor
dateCreated: 2025-11-19T19:47:10.413Z
-->

<h4>Connection to the Back-end Storage</h4>
<ul>
  <li>Configure a connection between the Kubernetes cluster and the back-end storage by using Container Storage Interface (CSI) plug-ins, and then creates storage classes to represent the available storage types in the back-end storage controller.</li>
  <li><strong>CSI plug-ins: </strong>The Kubernetes cluster plug-ins enable the cluster to interface with the specific storage back end and to provide persistent storage to containers.</li>
  <li><strong>Storage Classes: </strong>The storage class resources in Kubernetes describe the storage characteristics, such as quality of service, throughput, or technology that the backing data services provide.</li>
</ul>
<h4>Storage Class Annotations</h4>
<ul>
  <li><strong>storageclass.kubernetes.ioâ€‹/is-default-class=â€‹true</strong></li>
  <li><strong>storageclass.kubevirt.ioâ€‹/is-default-virt-class=â€‹true</strong>
    <ul>
      <li>OpenShift Data Foundation creates this storage class when it detects that OpenShift Virtualization is installed on the cluster.</li>
    </ul>
  </li>
</ul>
<h3>Persistent Storage Configuration for Virtual Machines</h3>
<ul>
  <li>A VM disk uses a PV that contains a disk image. For example, the root disk of a VM uses a PV that stores the operating system disk image.</li>
  <li>With PVCs in <code>Block</code> mode, OpenShift Virtualization transfers the disk image into the volume. The VM disk uses the volume as its back-end device.</li>
  <li>With PVCs in <code>Filesystem</code> mode, OpenShift Virtualization creates a <code>disk.img</code> file at the root of the PV file system and then copies the disk image into the file. The VM disk uses the <code>disk.img</code> file as its back-end device.</li>
  <li><strong>Storage profile:</strong>
    <ul>
      <li><strong>&nbsp;</strong>For each storage class, a storage profile resource gives default values that are optimized for VM disks. Storage profiles are cluster-wide resources.</li>
      <li>Storage profiles have the same name as their associated storage classes.</li>
      <li>The default settings for a storage profile are determined by the order in which the access mode and volume modes are declared.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">apiVersion: cdi.kubevirt.io/v1beta1
kind: StorageProfile
metadata:
  name: &lt;unknown_provisioner_class&gt;
# ...
spec:
  claimPropertySets:
  - accessModes:
    - ReadWriteOnce  1 
    volumeMode: Filesystem  2 
status:
  provisioner: &lt;unknown_provisioner&gt;
  storageClass: &lt;unknown_provisioner_class&gt;</code></pre>
<p><a href="https://docs.redhat.com/en/documentation/openshift_container_platform/4.18/html/virtualization/storage#CO117-1"><strong>1 </strong></a>Specify the <code>accessModes</code>.</p>
<p><a href="https://docs.redhat.com/en/documentation/openshift_container_platform/4.18/html/virtualization/storage#CO117-2"><strong>2 </strong></a>Specify the <code>volumeMode</code>.</p>
<blockquote>
  <p>As a developer, when you use a storage profile to prepare a VM disk, the only parameter that you must provide is the disk size. The storage profile ensures that all the other parameters have an optimal value for VM disk usage.</p>
  <p>The <code>StorageProfile</code> acts behind the scenes, tied to the <code>storageClassName</code></p>
</blockquote>
<ul>
  <li><strong>Data volume: </strong>A data volume resource describes a VM disk. It groups the PVC definition and the details of the disk image to inject into the PV. Data volumes are namespaced resources.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: cdi.kubevirt.io/v1beta1
kind: DataVolume
metadata:
  name: vm1	1
  namespace: storage-intro	2
  ...output omitted...
spec:
  pvc:
    accessModes:
    - ReadWriteMany	3
    resources:
      requests:
        storage: 10Gi	4
    storageClassName: ocs-external-storagecluster-ceph-rbd-â€‹virtualization	5
    volumeMode: Block	6
  source:
    http:
      url: http://images.example.com/openshift4/images/mariadb-server.qcow2	7</code></pre>
<p>&nbsp;</p>
<figure class="table">
  <table style="background-color:rgb(255, 255, 255);">
    <tbody>
      <tr>
        <td style="padding:0px;vertical-align:top;">
          <figure class="image image_resized" style="width:22px;"><img src="https://rol.redhat.com/rol/static/roc/Common_Content/images/1.svg" alt="1"></figure>
        </td>
        <td style="padding:0px;vertical-align:top;">The name of the data volume resource.</td>
      </tr>
      <tr>
        <td style="padding:0px;vertical-align:top;">
          <figure class="image image_resized" style="width:22px;"><img src="https://rol.redhat.com/rol/static/roc/Common_Content/images/2.svg" alt="2"></figure>
        </td>
        <td style="padding:0px;vertical-align:top;">The namespace that contains this data volume resource.</td>
      </tr>
      <tr>
        <td style="padding:0px;vertical-align:top;">
          <figure class="image image_resized" style="width:22px;"><img src="https://rol.redhat.com/rol/static/roc/Common_Content/images/3.svg" alt="3"></figure>
        </td>
        <td style="padding:0px;vertical-align:top;">The associated PVC requests a volume with the <code>ReadWriteMany</code> access mode.</td>
      </tr>
      <tr>
        <td style="padding:0px;vertical-align:top;">
          <figure class="image image_resized" style="width:22px;"><img src="https://rol.redhat.com/rol/static/roc/Common_Content/images/4.svg" alt="4"></figure>
        </td>
        <td style="padding:0px;vertical-align:top;">The requested volume size for the persistent volume claim.</td>
      </tr>
      <tr>
        <td style="padding:0px;vertical-align:top;">
          <figure class="image image_resized" style="width:22px;"><img src="https://rol.redhat.com/rol/static/roc/Common_Content/images/5.svg" alt="5"></figure>
        </td>
        <td style="padding:0px;vertical-align:top;">The requested storage class for the persistent volume claim.</td>
      </tr>
      <tr>
        <td style="padding:0px;vertical-align:top;">
          <figure class="image image_resized" style="width:22px;"><img src="https://rol.redhat.com/rol/static/roc/Common_Content/images/6.svg" alt="6"></figure>
        </td>
        <td style="padding:0px;vertical-align:top;">The associated PVC requests a block volume.</td>
      </tr>
      <tr>
        <td style="padding:0px;vertical-align:top;">
          <figure class="image image_resized" style="width:22px;"><img src="https://rol.redhat.com/rol/static/roc/Common_Content/images/7.svg" alt="7"></figure>
        </td>
        <td style="padding:0px;vertical-align:top;">Use the disk image from this URL to initialize the persistent volume. OpenShift Virtualization can import the image from this location or by cloning another PVC.</td>
      </tr>
    </tbody>
  </table>
</figure>
<blockquote>
  <p>When the PVC to create is in <code>Filesystem</code> mode, the data volume automatically instructs Kubernetes to create the PVC 5.5% larger than requested to account for file system overhead. By doing so, Kubernetes ensures that it can create the disk image file, <code>disk.img</code>, with the requested size.</p>
</blockquote>
<blockquote>
  <p>Deleting a data volume resource triggers the deletion of the associated PVC and PV. However, if the volume is attached to a VM, then the deletion occurs only after you detach the volume</p>
</blockquote>
<blockquote>
  <p>You can attach or remove disks in running VMs. The <code>virtio-scsi</code> controller on each VM eliminates the prior limitations of <code>virtio</code>. The new controller is highly scalable and supports the hot plugging of over four million disks.</p>
</blockquote>
<h4>Using Local Node Disk Space for Virtual Machine Disks</h4>
<ul>
  <li>Kubernetes <code>hostPath</code> volume</li>
  <li>Local Storage Operator</li>
  <li>LVM Storage Operator</li>
</ul>
<h4>Cloning Virtual Machine Disks</h4>
<ul>
  <li>only users with appropriate access to the <code>datavolumes</code> project can clone disks across multiple namespaces.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: &lt;EXAMPLE-ROLE-NAME&gt;  
rules:
- apiGroups: ["cdi.kubevirt.io"]
  resources: ["datavolumes/source"]
  verbs: ["*"]</code></pre>
<h3>Connect a Virtual Machine to Multiple Disks</h3>
<ul>
  <li>The VM disks can be imported from a URL or cloned from an existing PVC.</li>
  <li>Inside the VM, each data volume shows as a disk that you can partition, format, and then mount by using the operating system tools.</li>
  <li>Disk interfaces:<ul>
      <li><strong>SCSI: </strong>Linux systems name these disks in the <code>/dev/sd<i>X</i></code> format ðŸ‘Œ</li>
      <li><strong>VirtIO: </strong>Using this interface requires an available <mark class="marker-yellow">PCIe slot </mark>on the VM to mount the device, which limits the number of disks that you can attach in this manner. Linux systems include the driver and name these disks in the <code>/dev/vd<i>X</i></code> format.</li>
      <li><strong>VirtIO-SCSI: </strong>This interface is available in Red&nbsp;Hat OpenShift 4.16 and later versions for creating<mark class="marker-yellow"> hot pluggable disks.</mark>
        <ul>
          <li><code>virtio-scsi</code> interface relies on a VM controller to provide access for the hot pluggable disks to the <code>scsi</code> bus.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h4>Select a Data Volume Source</h4>
<ol>
  <li><strong>Ephemeral disk (container image):</strong>
    <ul>
      <li>OpenShift Virtualization downloads the container image from a container registry and uses the disk in that container image as the VM disk.</li>
      <li>intended for read-only file systems and short-lived VMs</li>
      <li>OpenShift Virtualization pulls that container image into the cluster, mounts the disk file from inside the container, and presents it to the VM as a virtual disk.</li>
      <li>the data that you write is not persistent. Whenever you restart the VM, OpenShift Virtualization discards your data and restores the disk image to its initial state.</li>
    </ul>
  </li>
  <li><strong>PVC:&nbsp;</strong>
    <ul>
      <li>OpenShift Virtualization copies the PVC that you provide and then uses that copy as the VM disk.</li>
      <li>the source PVC must not be in use for the cloning process to start</li>
    </ul>
  </li>
  <li><strong>Empty disk (blank):&nbsp;</strong>
    <ul>
      <li>The new PVC provides an unformatted raw device.</li>
    </ul>
  </li>
  <li><strong>From URL:</strong>
    <ul>
      <li>Red&nbsp;Hat OpenShift Virtualization downloads the virtual disk image from the URL that you provide, and then extracts this image to the new volume.</li>
      <li>The virtual disk image must be in the raw format or in the <i>QEMU copy on write version 2 (</i><code><i>qcow2</i></code><i>)</i> format.</li>
    </ul>
  </li>
  <li><strong>Registry (creates PVC):</strong>
    <ul>
      <li>OpenShift Virtualization downloads the container image from a container registry. The container image contains a disk image in the raw or <code>qcow2</code> format in the <code>/disk/</code> directory. OpenShift Virtualization extracts that disk image and copies it to the volume.</li>
    </ul>
  </li>
  <li><strong>Upload:</strong>
    <ul>
      <li>upload an existing <code>qcow2</code> disk image to the cluster and use it in a VM</li>
    </ul>
  </li>
</ol>
<h4>Preallocating Disk Space</h4>
<pre><code class="language-plaintext">apiVersion: cdi.kubevirt.io/v1beta1
kind: DataVolume
metadata:
  name: datadisk
spec:
  preallocation: true
  storage:
    resources:
      requests:
        storage: 10Gi
    storageClassName: ocs-external-storagecluster-ceph-rbd-â€‹virtualization
  source:
    blank: {}</code></pre>
<h4>Resize a Virtual Machine Disk</h4>
<ul>
  <li>When you change the size of a PVC, Red&nbsp;Hat OpenShift automatically resizes the associated PV</li>
</ul>
<pre><code class="language-plaintext">oc get storageclass \
  ocs-external-storagecluster-ceph-rbd-â€‹virtualization -o yaml | \
  grep allowVolumeExpansion
allowVolumeExpansion: true</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">oc edit pvc/mariadb-server-my-disk-rbd</code></pre>
<h4>Inject a Disk Image into the Volume</h4>
<pre><code class="language-plaintext"> virtctl image-upload pvc websrv1-staticimgs \
  --image-path=./webimgfs.qcow2 --no-create</code></pre>
<h3>Take Snapshots of Virtual Machines</h3>
<ul>
  <li>Red&nbsp;Hat OpenShift Virtualization can take live snapshots of running VMs, as well as snapshots of stopped VMs.</li>
  <li>OpenShift Virtualization communicates with the Quick Emulator (QEMU) guest agent that is running inside the VM to quiesce the file systems before taking the snapshot.</li>
  <li>If one VM disk relies on back-end storage that does not support snapshots, then OpenShift Virtualization displays a warning message when you take a snapshot.</li>
  <li>Red&nbsp;Hat supports taking a live snapshot of a VM with hot-plugged disks. However, the snapshot includes only the hot-plugged disks in the VM specification. <i>Hot-plugged</i> refers to disks that you attach to a running VM.</li>
  <li>A VM snapshot also records the VM configuration, such as the number of CPUs or the amount of memory.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: snapshot.kubevirt.io/v1alpha1
kind: VirtualMachineSnapshot
metadata:
  name: mariadb-server-2024-10-23
spec:
  source:
    apiGroup: kubevirt.io
    kind: VirtualMachine
    name: mariadb-server</code></pre>
<pre><code class="language-plaintext"> oc get virtualmachinesnapshot</code></pre>
<pre><code class="language-plaintext">apiVersion: snapshot.kubevirt.io/v1alpha1
kind: VirtualMachineRestore
metadata:
  name: restore-db
spec:
  target:
    apiGroup: kubevirt.io
    kind: VirtualMachine
    name: mariadb-server
  virtualMachineSnapshotName: mariadb-server-2024-10-23</code></pre>
<p>&nbsp;</p>
<h3>Copy Kubernetes Volume Snapshots</h3>
<ul>
  <li>VM snapshots rely on Kubernetes volume snapshots. When you take a snapshot of a VM, OpenShift Virtualization creates a Kubernetes volume snapshot for each VM disk.</li>
</ul>
<h4>Backing up a Virtual Machine by OADP</h4>
<ul>
  <li>OADP can back up virtual machines that are running on the OpenShift cluster. To back up a virtual machine, you must include the <code>kubevirt.io/virtualmachine</code> resource type in the backup definition.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: velero.io/v1
kind: Backup
metadata:
  name: my-vm-backup
  namespace: openshift-adp
spec:
  includedNamespaces:
  - my-vm
  includedResources:
  - kubevirt.io/virtualmachine
  hooks:
    resources:
    - name: my-vm-pre-backup
      labelSelector:
        matchLabels:
          kubevirt.io/virtualmachine: my-vm
      pre:
      - exec:
          container: my-vm
          command:
          - /usr/bin/virsh
          - suspend</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">apiVersion: velero.io/v1
kind: Restore
metadata:
  name: my-vm-restore
  namespace: openshift-adp
spec:
  backupName: my-vm-backup
  hooks:
    resources:
    - name: my-vm-post-restore
      labelSelector:
        matchLabels:
          kubevirt.io/virtualmachine: my-vm
      post:
      - exec:
          container: my-vm
          command:
          - /usr/bin/virsh
          - resume  my-vm</code></pre>
<ul>
  <li>Backing up Volumes with Kopia</li>
</ul>
<pre><code class="language-plaintext">apiVersion: velero.io/v1
kind: Backup
metadata:
  name: &lt;backup-name&gt;
  namespace: openshift-adp
spec:
  defaultVolumesToFsBackup: true</code></pre>
<ul>
  <li>annotate the application pod to specify which volumes to back up with Kopia by using the<mark class="marker-yellow"> backup.velero.io/backup-volumes: volume1,volume2,volume3</mark> annotation.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: apps/v1
kind: Deployment
metadata:
  name: website-mariadb
  namespace: org-website
spec:
  template:
    metadata:
      annotations:
        backup.velero.io/backup-volumes: mariadb 
    spec:
      containers:
        name: db
        image: registry.access.redhat.com/rhscl/mariadb-105-rhel7
        ...output omitted...
        volumeMounts:
        - mountPath: /var/lib/mysql
          name: mariadb
      ...output omitted...
      volumes:
      - name: mariadb
        persistentVolumeClaim:
          claimName: mariadb-data
...output omitted...</code></pre>
