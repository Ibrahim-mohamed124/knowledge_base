<!--
title: secret engines
description: 
published: true
date: 2025-11-04T18:16:47.187Z
tags: vault
editor: ckeditor
dateCreated: 2025-10-14T17:07:31.158Z
-->

<h1>Secret Engines</h1>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td>Dynamic secrets</td>
        <td>Static Secrets</td>
      </tr>
      <tr>
        <td>associated leases&nbsp;</td>
        <td>Do no expire</td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>Shared between team members</td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>No accountability&nbsp;</td>
      </tr>
      <tr>
        <td>Created on-demand&nbsp;</td>
        <td>Valid 24/7</td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>a target for pentesters</td>
      </tr>
      <tr>
        <td>automatically rotated and revoked</td>
        <td>manual rotation&nbsp;</td>
      </tr>
      <tr>
        <td>Short lived</td>
        <td>Long lived</td>
      </tr>
      <tr>
        <td>can be renewed</td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
</figure>
<ul>
  <li>plugins that can extend the functionality of vault</li>
  <li>can store, generate, and delete secrets.</li>
  <li>multilabel instance of the same engine can be enabled at different paths</li>
  <li>secret as a service: manage the lifecycle of secrets</li>
  <li><mark class="marker-yellow">audit trail can identify points of compromise</mark> &nbsp;: because vault generate unique secrets to every instance that can authenticate to it, you can point to the one that leaked its dynamically created credentials unlike sharing one static secret with all the instance.</li>
</ul>
<h3>Operations</h3>
<ul>
  <li><mark class="marker-yellow">identify and cubbyhole are enabled by default</mark>, others must be enabled by users</li>
  <li>enabled at unique paths by admins</li>
  <li>configured by the admins, and granted access to the backend after establishing connectivity to it</li>
  <li>policies to access this engines are created by admins</li>
</ul>
<pre><code class="language-plaintext">$ vault secrets [list|enalbe|disable|move|tune] &lt;engine_name&gt; or -options /path</code></pre>
<h4>Secret engine configuration</h4>
<ol>
  <li>Configure vault access to the backend platform</li>
  <li>Configure roles based on permissions needed on the backend</li>
</ol>
<p>&nbsp;</p>
<h2>K/V secret engine</h2>
<ul>
  <li>store static secrets</li>
  <li>version 2 is versioned and return the latest version, version 1 is overwriting</li>
</ul>
<pre><code class="language-plaintext"> vault kv enable-versioning v1&gt;v2</code></pre>
<p>&nbsp;</p>
<ul>
  <li><mark class="marker-yellow">version 2 stores the data under mount/data/path and the metadata under mount/metadata/path</mark></li>
  <li>Deleting a version deletes only the latest slot ( keeping the version itself ) and it is possible to rollback to pervious versions, but destroying a version will not keep the version and you cannot rollback to it from the latest.</li>
</ul>
<pre><code class="language-plaintext">$ vault kv put|get|delete|list and for the versioned one undelete|destroy|patch|rollback</code></pre>
<h2>Transit secret engine</h2>
<ul>
  <li>Encrypt/Decrypt application data in the database by receiving data from the app tier and encrypt it then send back Ciphertext data to the app</li>
</ul>
<blockquote>
  <p>In cryptography, ciphertext or cyphertext is <i><strong>the result of encryption performed on plaintext using an algorithm</strong></i></p>
</blockquote>
<ul>
  <li>&nbsp;centralize encryption services</li>
  <li>Decouples storage from encryption layer</li>
  <li>Encryption keys always live in vault, created, rotated, and storied as keyrings per application</li>
  <li>key versioning, all the versions are storied in a keyring, and put a limit on what version can be used to decrypt data, so older data that has been encrypted by older versions cannot be decrypted.</li>
  <li>&nbsp;keys can be exported but need extra permissions</li>
  <li>rewrap ciphertexts with new versions of the keys internally without having to decrypt and encrypt depending on an external storage</li>
  <li>Convergent encryption mode: every time the same data is encrypted vault will return the same ciphertext, which enables searchable ciphertexts</li>
  <li>Data must be base64 encoded (text, pdf, imagesâ€¦)</li>
</ul>
<h3>Operations</h3>
<ol>
  <li>Encryption keys creation:&nbsp;</li>
</ol>
<pre><code class="language-plaintext">$ vault write -f  transit/keys/&lt;key_name&gt; -type=&lt;type&gt;</code></pre>
<p>&nbsp;2. To encrypt data</p>
<pre><code class="language-plaintext">$ vault write  transit/encrypt/&lt;name&gt; plaintext=$(base64 &lt;&lt;&lt; "data")</code></pre>
<p>&nbsp;3. To decrypt data</p>
<pre><code class="language-plaintext">$ vault write tranist/decrypt/&lt;name&gt;  ciphertext=""</code></pre>
<p>4. Rotating encryption keys manually or auto-rotation&nbsp;</p>
<pre><code class="language-plaintext">$ vault write transit/keys/&lt;name&gt;/rotate</code></pre>
<p>5. limit what version of keys can be used to decrypt data</p>
<pre><code class="language-plaintext">$ vault write transit/keys/&lt;name&gt;/config min_decryption_version=x</code></pre>
<p>6. rewrapping ciphertext</p>
<pre><code class="language-plaintext">$ vault write transit/rewrap/&lt;name&gt;  ciphertext=""</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
