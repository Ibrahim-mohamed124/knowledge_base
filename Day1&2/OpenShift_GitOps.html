<!--
title: OpenShift GitOps
description: 
published: true
date: 2025-11-27T13:52:12.951Z
tags: 
editor: ckeditor
dateCreated: 2025-11-27T10:08:04.851Z
-->

<h3>Introduction to OpenShift GitOps</h3>
<ul>
  <li>OpenShift GitOps is an operator that manages Argo CD in OpenShift clusters.</li>
  <li>The OpenShift GitOps operator installs the <code>ArgoCD</code> custom resource definition (including RBAC configuration).</li>
  <li>The OpenShift GitOps operator configures Dex to delegate the authentication to the built-in OAuth server in OpenShift. Thus, Dex provides the users and groups that are defined in OpenShift.</li>
  <li>Cluster administrators can use OpenShift GitOps to create Argo CD instances with specific access rights.</li>
  <li>Administrators can create an Argo CD instance that can <mark class="marker-yellow">manage specific namespaces and grant specific users access to the instance.</mark></li>
</ul>
<figure class="image image_resized" style="width:100%;"><img src="/gitops-dev.svg"></figure>
<ul>
  <li>OpenShift GitOps also includes <mark class="marker-yellow">a default administrative Argo CD instance that can manage Kubernetes resources that require administrative access,</mark> such as non-namespaced resources or authentication resources.</li>
</ul>
<figure class="image image_resized" style="width:100%;"><img src="/gitops-admin.svg"></figure>
<ul>
  <li>An application is an Argo CD resource that references a Git repository with Kubernetes resource definitions.</li>
</ul>
<h3><strong>Red&nbsp;Hat OpenShift Pipelines</strong></h3>
<ul>
  <li>based on the open source Tekton project, and can run processes when changes occur to a Git repository.</li>
</ul>
<h3>The Default Argo CD Instance</h3>
<ul>
  <li>By default, the OpenShift GitOps operator creates a default Argo CD instance with the <code>openshift-gitops</code> name for both the instance and the namespace. This default instance has a set of permissions to support cluster administration.</li>
</ul>
<h3>Configuring Argo CD RBAC</h3>
<ul>
  <li>Argo CD can use both local users that are defined in Argo CD and users from external authentication systems. The OpenShift GitOps operator includes features to automate integration with the OpenShift cluster authentication.</li>
  <li>Argo CD updates the cluster by using a Kubernetes service account. Even unrestricted users in Argo CD are limited in how they can update the cluster, according to the permissions of the Argo CD service account.</li>
  <li>The <code>openshift-gitops-cluster</code> secret in the <code>openshift-gitops</code> namespace contains the password for the admin user.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
  ...output omitted...
spec:
  ...output omitted...
  rbac:
    defaultPolicy: ""
    policy: |
      g, system:cluster-admins, role:admin
      g, cluster-admins, role:admin
    scopes: '[groups]'
  ...output omitted...
  sso:
    dex:
      openShiftOAuth: true
...output omitted...</code></pre>
<blockquote>
  <p>The <code>sso</code> key contains the authentication configuration. In the default Argo CD instance, the <code>openShiftOAuth</code> key is set to the <code>true</code> value. With this configuration, OpenShift users can log in to the Argo CD web console by clicking <strong>LOG IN VIA OPENSHIFT</strong>. By default, OpenShift users have limited privileges.</p>
</blockquote>
<h3>Configuring Trusted Certificates for Git Repository Access</h3>
<ul>
  <li>The <i>repo server</i> component of Argo CD handles communicating with Git repositories. To change the trusted certificate authorities, modify the certificate bundle in the <code>/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem</code> path of the repo server.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
  ...output omitted...
spec:
  ...output omitted...
  repo:
    volumeMounts:
    - mountPath: /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
      name: volume_name
      subPath: bundle_name
    volumes:
    - configMap:
        name: configuration_map_name
      name: volume_name
...output omitted...</code></pre>
<h3>Customizing the Argo CD Web Interface Certificate</h3>
<ul>
  <li>The default Argo CD instance has its own self-signed HTTPS certificate. The Argo CD resource has a <code>termination</code> key to change the route termination. Use the <code>reencrypt</code> termination so that Argo CD uses the default router certificate.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: ArgoCD
metadata:
  ...output omitted...
spec:
  ...output omitted...
  server:
    ...output omitted...
    route:
      enabled: true
      tls:
        termination: reencrypt
...output omitted...</code></pre>
<h3>Deploying Complex Resources by Using Sync Waves and Retries</h3>
<ul>
  <li>use the <code>argocd.argoproj.io/sync-wave</code> annotation on resources to help with dependencies. The annotation value must be a positive or negative integer or zero. Resources without the annotation default to 0.</li>
  <li>A group of resources with the same annotation is a <i>sync wave</i>. Argo CD synchronizes sync waves in order, starting with sync waves with lower numbers. <mark class="marker-yellow">Argo CD synchronizes a sync</mark> <mark class="marker-yellow">wave only when all lower sync waves are healthy.</mark></li>
  <li><mark class="marker-yellow">Argo CD performs a dry run before synchronizations</mark>. When deploying custom resources, the synchronization continues only if the corresponding custom resource definitions exist when Argo CD performs the dry run. To prevent this problem, add the <code>argocd.argoproj.io/sync-options</code> annotation to these resources by adding the <code>SkipDryRunOnMissingResource=true</code> option.</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">---
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: example-operator
...output omitted...
---
kind: ExampleCustomResource
metadata:
  name: example
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "1"
...output omitted...</code></pre>
<ul>
  <li>Because systems that use eventual consistency do not apply updates immediately, updates can take a perceivable amount of time to be effective across the cluster or even in a single node.</li>
  <li>Sync waves are often insufficient when working with complex applications such as operators. If you face issues with deploying applications, then<mark class="marker-yellow"> consider configuring retries in your Argo CD applications for more reliable synchronization.</mark></li>
</ul>
<h3>Administrating Clusters with OpenShift GitOps</h3>
<ul>
  <li>Argo CD can use the <i>server-side apply</i> process to edit existing resources. The server-side apply process is an alternative to the client-side apply process that <code>kubectl apply</code> and other processes use by default.</li>
  <li>client-side apply, commands such as <code>kubectl apply</code> start by retrieving the resource definition from the API server. If the resource exists, then the client compares this retrieved resource definition with the definition that you provide. Then, the client sends a <code>PATCH</code> request to the API server with the updated parts.</li>
  <li>with server-side apply, your resource definition can include only your changes and exclude parts of the resource that you do not want to update. <mark class="marker-yellow">The client submits this partial resource definition, and the API server updates only the submitted parts. (kube apiserver)</mark></li>
  <li>For patching, use the <code>ServerSideApply=true</code> sync option. Also, add the <code>Validate=false</code> sync option to disable validation, because the partial resource definition might not be a valid complete resource definition.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: operator.openshift.io/v1
kind: Console
metadata:
  name: cluster
  annotations:
    argocd.argoproj.io/sync-options: ServerSideApply=true,Validate=false
spec:
  customization:
    customProductName: Production</code></pre>
<h4>Argo CD Instances</h4>
<ul>
  <li>By default, the new Argo CD instances have permissions to manage resources only in the namespace where they are deployed.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: argocd-name
  namespace: argocd-ns
spec:
...output omitted...</code></pre>
<ul>
  <li>allow an Argo CD instance to manage resources in other namespaces than where it is deployed by adding the <code>argocd.argoproj.io/managed-by</code> label to the namespace.&nbsp;</li>
  <li>Argo CD comes with the following predefined roles:<ul>
      <li><code>role:readonly</code> for read access to all the resources.</li>
      <li><code>role:admin</code> for read and write access to all the resources</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">...output omitted...
spec:
  ...output omitted...
  rbac:
    defaultPolicy: ""
    policy: |
      g, system:cluster-admins, role:admin
      g, cluster-admins, role:admin
    scopes: '[groups]'
...output omitted...</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
