<!--
title: OpenShift GitOps
description: 
published: true
date: 2025-11-27T17:43:54.248Z
tags: 
editor: ckeditor
dateCreated: 2025-11-27T10:08:04.851Z
-->

<h3>Introduction to OpenShift GitOps</h3>
<ul>
  <li>OpenShift GitOps is an operator that manages Argo CD in OpenShift clusters.</li>
  <li>The OpenShift GitOps operator installs the <code>ArgoCD</code> custom resource definition (including RBAC configuration).</li>
  <li>The OpenShift GitOps operator configures Dex to delegate the authentication to the built-in OAuth server in OpenShift. Thus, Dex provides the users and groups that are defined in OpenShift.</li>
  <li>Cluster administrators can use OpenShift GitOps to create Argo CD instances with specific access rights.</li>
  <li>Administrators can create an Argo CD instance that can <mark class="marker-yellow">manage specific namespaces and grant specific users access to the instance.</mark></li>
</ul>
<figure class="image image_resized" style="width:100%;"><img src="/gitops-dev.svg"></figure>
<ul>
  <li>OpenShift GitOps also includes <mark class="marker-yellow">a default administrative Argo CD instance that can manage Kubernetes resources that require administrative access,</mark> such as non-namespaced resources or authentication resources.</li>
</ul>
<figure class="image image_resized" style="width:100%;"><img src="/gitops-admin.svg"></figure>
<ul>
  <li>An application is an Argo CD resource that references a Git repository with Kubernetes resource definitions.</li>
</ul>
<h3><strong>Red&nbsp;Hat OpenShift Pipelines</strong></h3>
<ul>
  <li>based on the open source Tekton project, and can run processes when changes occur to a Git repository.</li>
</ul>
<h3>The Default Argo CD Instance</h3>
<ul>
  <li>By default, the OpenShift GitOps operator creates a default Argo CD instance with the <code>openshift-gitops</code> name for both the instance and the namespace. This default instance has a set of permissions to support cluster administration.</li>
</ul>
<h3>Configuring Argo CD RBAC</h3>
<ul>
  <li>Argo CD can use both local users that are defined in Argo CD and users from external authentication systems. The OpenShift GitOps operator includes features to automate integration with the OpenShift cluster authentication.</li>
  <li>Argo CD updates the cluster by using a Kubernetes service account. Even unrestricted users in Argo CD are limited in how they can update the cluster, according to the permissions of the Argo CD service account.</li>
  <li>The <code>openshift-gitops-cluster</code> secret in the <code>openshift-gitops</code> namespace contains the password for the admin user.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
  ...output omitted...
spec:
  ...output omitted...
  rbac:
    defaultPolicy: ""
    policy: |
      g, system:cluster-admins, role:admin
      g, cluster-admins, role:admin
    scopes: '[groups]'
  ...output omitted...
  sso:
    dex:
      openShiftOAuth: true
...output omitted...</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>The <code>sso</code> key contains the authentication configuration. In the default Argo CD instance, the <code>openShiftOAuth</code> key is set to the <code>true</code> value. With this configuration, OpenShift users can log in to the Argo CD web console by clicking <strong>LOG IN VIA OPENSHIFT</strong>. By default, OpenShift users have limited privileges.</p>
</blockquote>
<h3>Configuring Trusted Certificates for Git Repository Access</h3>
<ul>
  <li>The <i>repo server</i> component of Argo CD handles communicating with Git repositories. To change the trusted certificate authorities, modify the certificate bundle in the <code>/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem</code> path of the repo server.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: openshift-gitops
  namespace: openshift-gitops
  ...output omitted...
spec:
  ...output omitted...
  repo:
    volumeMounts:
    - mountPath: /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
      name: volume_name
      subPath: bundle_name
    volumes:
    - configMap:
        name: configuration_map_name
      name: volume_name
...output omitted...</code></pre>
<h3>Customizing the Argo CD Web Interface Certificate</h3>
<ul>
  <li>The default Argo CD instance has its own self-signed HTTPS certificate. The Argo CD resource has a <code>termination</code> key to change the route termination. Use the <code>reencrypt</code> termination so that Argo CD uses the default router certificate.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1alpha1
kind: ArgoCD
metadata:
  ...output omitted...
spec:
  ...output omitted...
  server:
    ...output omitted...
    route:
      enabled: true
      tls:
        termination: reencrypt
...output omitted...</code></pre>
<h3>Deploying Complex Resources by Using Sync Waves and Retries</h3>
<ul>
  <li>use the <code>argocd.argoproj.io/sync-wave</code> annotation on resources to help with dependencies. The annotation value must be a positive or negative integer or zero. Resources without the annotation default to 0.</li>
  <li>A group of resources with the same annotation is a <i>sync wave</i>. Argo CD synchronizes sync waves in order, starting with sync waves with lower numbers. <mark class="marker-yellow">Argo CD synchronizes a sync</mark> <mark class="marker-yellow">wave only when all lower sync waves are healthy.</mark></li>
  <li><mark class="marker-yellow">Argo CD performs a dry run before synchronizations</mark>. When deploying custom resources, the synchronization continues only if the corresponding custom resource definitions exist when Argo CD performs the dry run. To prevent this problem, add the <code>argocd.argoproj.io/sync-options</code> annotation to these resources by adding the <code>SkipDryRunOnMissingResource=true</code> option.</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">---
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: example-operator
...output omitted...
---
kind: ExampleCustomResource
metadata:
  name: example
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "1"
...output omitted...</code></pre>
<p>&nbsp;</p>
<ul>
  <li>Because systems that use eventual consistency do not apply updates immediately, updates can take a perceivable amount of time to be effective across the cluster or even in a single node.</li>
  <li>Sync waves are often insufficient when working with complex applications such as operators. If you face issues with deploying applications, then<mark class="marker-yellow"> consider configuring retries in your Argo CD applications for more reliable synchronization.</mark></li>
</ul>
<h3>Administrating Clusters with OpenShift GitOps</h3>
<ul>
  <li>Argo CD can use the <i>server-side apply</i> process to edit existing resources. The server-side apply process is an alternative to the client-side apply process that <code>kubectl apply</code> and other processes use by default.</li>
  <li>client-side apply, commands such as <code>kubectl apply</code> start by retrieving the resource definition from the API server. If the resource exists, then the client compares this retrieved resource definition with the definition that you provide. Then, the client sends a <code>PATCH</code> request to the API server with the updated parts.</li>
  <li>with server-side apply, your resource definition can include only your changes and exclude parts of the resource that you do not want to update. <mark class="marker-yellow">The client submits this partial resource definition, and the API server updates only the submitted parts. (kube apiserver)</mark></li>
  <li>For patching, use the <code>ServerSideApply=true</code> sync option. Also, add the <code>Validate=false</code> sync option to disable validation, because the partial resource definition might not be a valid complete resource definition.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: operator.openshift.io/v1
kind: Console
metadata:
  name: cluster
  annotations:
    argocd.argoproj.io/sync-options: ServerSideApply=true,Validate=false
spec:
  customization:
    customProductName: Production</code></pre>
<h4>Argo CD Instances</h4>
<ul>
  <li>By default, the new Argo CD instances have permissions to manage resources only in the namespace where they are deployed.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: argoproj.io/v1beta1
kind: ArgoCD
metadata:
  name: argocd-name
  namespace: argocd-ns
spec:
...output omitted...</code></pre>
<p>&nbsp;</p>
<ul>
  <li>allow an Argo CD instance to manage resources in other namespaces than where it is deployed by adding the <code>argocd.argoproj.io/managed-by</code> label to the namespace.</li>
  <li>Argo CD comes with the following predefined roles:<ul>
      <li><code>role:readonly</code> for read access to all the resources.</li>
      <li><code>role:admin</code> for read and write access to all the resources</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">...output omitted...
spec:
  ...output omitted...
  rbac:
    defaultPolicy: ""
    policy: |
      g, system:cluster-admins, role:admin
      g, cluster-admins, role:admin
    scopes: '[groups]'
...output omitted...</code></pre>
<h4>Fine-grained RBAC</h4>
<ul>
  <li>The resources in Argo CD are <code>accounts</code>, <code>applications</code>, <code>applicationsets</code>, <code>certificates</code>, <code>clusters</code>, <code>exec</code>, <code>extensions</code>, <code>gpgkeys</code>, <code>logs</code>, <code>projects</code>, and <code>repositories</code>.</li>
  <li>For all the resources, the Argo CD actions include <code>create</code>, <code>delete</code>, <code>get</code>, and <code>update</code>. For the <code>applications</code> resource, Argo CD also includes the <code>action/<i>group</i>/<i>kind</i>/<i>action-name</i></code>, <code>override</code>, and <code>sync</code> actions.</li>
</ul>
<pre><code class="language-plaintext">p, role/user/group, resource, action, target</code></pre>
<p>&nbsp;</p>
<ul>
  <li>The <code><i>target</i></code> field differs between the application resources and the other resources:<ul>
      <li>For the <code>applications</code>, <code>applicationsets</code>, <code>logs</code>, and <code>exec</code> resources, which belong to a project, the <code>target</code> field is <code><i>project</i>/<i>object</i></code>.</li>
      <li>For other resources, the <code>target</code> field is <code><i>object</i></code>.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">...output omitted...
spec:
  ...output omitted...
  rbac:
    defaultPolicy: ''
    policy: |
      g, project-devs, role:project-devs      &gt;&gt;&gt;&gt;&gt; group, role:group
      p, role:project-devs, applications, get, */*, allow  permission &gt;&gt; role?? action on what??
      p, role:project-devs, projects, get, *, allow
      p, role:project-devs, clusters, get, *, allow
      g, project-admins, role:project-admins
      p, role:project-admins, applications, *, */*, allow
      p, role:project-admins, projects, get, *, allow
      p, role:project-admins, clusters, get, *, allow
    scopes: '[groups]'
...output omitted...</code></pre>
<h3>Monorepo and Polyrepo Environments</h3>
<ul>
  <li>When setting up Git workflows for GitOps, you can either create only one repository for all your files, which is called a <i>monorepo environment</i>, or create repositories for different concerns, which is called a <i>polyrepo environment</i>.</li>
  <li>From an Argo CD perspective, you can either treat the entire monorepo as a single application, to deploy changes across various services or components concurrently, or use paths to create several applications from a single repository.</li>
</ul>
<h4>Organizing Applications by Environment</h4>
<ol>
  <li>One GitOps practice<mark class="marker-yellow"> separates the test and production environments by directory inside a Git repository</mark>, instead of creating different branches for them.<ul>
      <li>Tools such as <mark class="marker-yellow">Kustomize or Helm create reusable and modular configurations, to separate base manifests and environment-specific adjustments.</mark></li>
    </ul>
  </li>
  <li>Separate the test and production environments by different repos.</li>
</ol>
<h3>Managing Sensitive Data in GitOps</h3>
<ul>
  <li>Secrets Store CSI Driver operator to manage multiple secrets, keys, and certificates.&nbsp;<ul>
      <li>enables Kubernetes pods to mount secrets that are stored in external secret management systems such as Azure Key Vault, AWS Secrets Manager, or<mark class="marker-yellow"> HashiCorp Vault as volumes.&nbsp;</mark></li>
    </ul>
  </li>
</ul>
<h4>Argo CD Resource Hooks</h4>
<ul>
  <li>With Argo CD resource hooks, you can define and execute actions during the lifecycle of an application synchronization process.<ul>
      <li><code><strong>PreSync: </strong></code>Argo CD executes these hooks <mark class="marker-yellow">before </mark>applying the manifests.</li>
      <li><code><strong>Sync: </strong></code>Argo CD executes these hooks only after it successfully completes all the <code>PreSync</code> hooks. These hooks are applied at the <mark class="marker-yellow">same time</mark> as applying the manifests.</li>
      <li><code><strong>Skip: </strong></code>This hook indicates to <mark class="marker-yellow">Argo CD to skip applying the manifests</mark>. Use this hook for resources that Argo CD must create, but that other resources modify and that must be out of Argo CD synchronization.</li>
      <li><code><strong>PostSync: </strong></code>Argo CD executes these hooks only <mark class="marker-yellow">after </mark>it successfully completes all the <code>Sync</code> hooks, and the application and its resources are in a healthy state.</li>
      <li><code><strong>SyncFail: </strong></code>Argo CD executes these hooks whenever the synchronization operation <mark class="marker-yellow">fails</mark>.</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>Argo CD resource hooks are Kubernetes resources that include the <code>argocd.argoproj.io/hook</code> annotation. Typically, Argo CD resource hooks are implemented through Kubernetes jobs.</p>
</blockquote>
<pre><code class="language-plaintext">apiVersion: batch/v1
kind: Job
metadata:
  generateName: schema-migrate-database
  annotations:
    argocd.argoproj.io/hook: PreSync
...output omitted...</code></pre>
<ul>
  <li>add the <code>argocd.argoproj.io/hook-delete-policy</code> annotation for your hooks, so Argo CD deletes them automatically according to one of the following policies:<ul>
      <li><code><strong>HookSucceeded: </strong></code>Delete the hook resource after the hook succeeds.</li>
      <li><code><strong>HookFailed: </strong></code>Delete the hook resource after the hook fails.</li>
      <li><code><strong>BeforeHookCreation: </strong></code>Delete any existing hook resource before a new one is created.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">apiVersion: batch/v1
kind: Job
metadata:
  generateName: integration-test-app
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
...output omitted...</code></pre>
<h4>Argo CD Rollbacks And Rollouts</h4>
<ul>
  <li>Argo CD can also automate rollbacks in certain conditions, such as for failing resource hooks.</li>
</ul>
<blockquote>
  <p>The Argo CD rollback feature is disabled if you enable automatic synchronization for your application, because Argo CD automatically synchronizes the application to the latest Git commit version.</p>
</blockquote>
<ul>
  <li>integrate Argo Rollouts with ingress controllers and service meshes, to gradually shift the traffic from your previous application version to a new one.</li>
</ul>
