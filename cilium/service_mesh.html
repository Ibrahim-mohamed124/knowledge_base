<!--
title: Service Mesh
description: 
published: true
date: 2025-12-26T11:57:00.810Z
tags: 
editor: ckeditor
dateCreated: 2025-12-19T20:00:13.689Z
-->

<h1>What are Service Mesh</h1>
<ul>
  <li>Helps adding new features to applications without having to modify the &nbsp;source code. In other words, service mesh adds intelligence without rework.</li>
  <li>This code be achieved by sidecar or sidecarless strategies</li>
  <li>Benefits:<ul>
      <li>Traffic management</li>
      <li>observability</li>
      <li>mTLS</li>
      <li>Resilience</li>
      <li>Decoupling network logic from application logic</li>
      <li>Consistency</li>
      <li>Version Control</li>
    </ul>
  </li>
  <li>Cilium work by a sidecar-less strategy only for layer 3 and 4 (eBPF), layer 7 features use only one sidecar server for all the pods ( one extra hop )</li>
</ul>
<h3>cilium ingress</h3>
<ul>
  <li>Ingress is implemented by eBPF programs and envoy</li>
  <li>in the values.yaml change ingressController.enabled to true and ingressController.default to true. Then, just set nodePort.enabled to ture if cilium replaced kubeproxy</li>
</ul>
<pre><code class="language-plaintext">helm show values cilium/cilium &gt;&gt; values.yaml

vim values.yaml
nodePort:
  # -- Enable the Cilium NodePort service implementation.
  enabled: true
ingressController:
  # -- Enable Cilium ingress controller.
  # This will automatically set enable-envoy-config as well.
  enabled: true
  # -- Designate the Cilium ingress controller as the default ingress controller.
  # This will allow the Cilium ingress controller to route entries without an ingress class specified.
  default: true
  # -- Specify the default ingress load balancer mode.
  # Possible values are "ingress.cilium.io/loadbalancer-mode: dedicated" or "shared".
  loadbalancerMode: shared
  
  
helm upgrade cilium cilium/cilium -n kube-system -f values.yaml


kubectl -n kube-system rollout restart deployment/cilium-operator
kubectl -n kube-system rollout restart daemonset/cilium</code></pre>
<p>&nbsp;</p>
<ul>
  <li>loadbalancerMode: shared or dedicated</li>
  <li>cilium creates an ingressClass and use it as the default one</li>
</ul>
<pre><code class="language-plaintext">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress
spec:
  ingressClassName: cilium
  rules:
  - host: ""
    http:
     paths:
     - pathType: Prefix
       path: "/"
       backend:
         service:
           name: 
           port:
             number: 
     - pathType: Prefix
       path: ""
       backend:
         service:
           name: 
           port:
             number: 
  - host: ""
    http:
     paths:
     - pathType: Prefix
       path: ""
       backend:
         service:
           name: 
           port:
             number: 
  - http:                                          &gt;&gt;&gt; the defaul path if no rule is matched
      paths:
       - pathType: Prefix
         path: /
         backend:
          service:
            name: test
            port:
              number: </code></pre>
<h3>Gateway API</h3>
<h6>Limitations of Ingress Controller</h6>
<ul>
  <li>Only match on the host and path</li>
  <li>No traffic splitting</li>
  <li>ONLY support HTTP/S</li>
  <li>No RateLimiting</li>
  <li>All the configuration is in the ingress object</li>
  <li>Cannot change the headers of a request/respone</li>
</ul>
<h6>Gateway API</h6>
<ul>
  <li>Enable it by setting gatewayAPI.enabled to true in the values.yaml file and installing the API gateway CRDs from its documentation the<mark class="marker-yellow"> experimental channel not the standard one</mark></li>
  <li>Separation of Concerns:<ul>
      <li>GatewayClass: what type of gateway controller will be used?? Nginx, others?? built by the infra team</li>
      <li>Gateway: configure an instance of the gateway controller &nbsp;built by platform operator</li>
      <li>HTTPRoute, TCPRoute, GRCPRoute: is the configuration for a specific endpoint built by the developer</li>
    </ul>
  </li>
  <li>Cross namespaces: Gateway API is able to route traffic to different specific namespaces and prevent other namespaces to attach endpoints to the gatgeway</li>
</ul>
<pre><code class="language-plaintext">created automatically by cilium
kind: GatewayClass
metadata: 
  name: cluster-gateway
spec:
 controllerName: "cilium"</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: my-gateway
  namespace: default
spec:
  gatewayClassName: cilium
  listeners:
  - name: http
    protocol: HTTP
    port: 80
    allowedRoutes:
      namespaces:
        from: Same
  - name: https
    protocol: HTTPS
    port: 443
    tls:
      mode: Terminate
      certificateRefs:
      - kind: Secret
        name: my-cert
        namespace: default
    allowedRoutes:
      namespaces:
        from: Same</code></pre>
<p>&nbsp;</p>
<ul>
  <li>This will create a gateway instance in that namespace and a load balancer service that listen on port 80</li>
</ul>
<pre><code class="language-plaintext">apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata: 
	 name: test
spec:
  parentRefs:
  - name: cluster-gateway
  hostnames:
  - "test.com"
  rules:
   - matches:
     - path:
        type: PathPrefix
        vaule: /login
       headers:
        - name: Host
          value: "test1.com"   || either this or use the hostname above
     backendRefs:
     - name: svc
       port: 80
   - backendRefs:   | the default backend
     - name: svc
       port: 80</code></pre>
<h3>Data Encryption</h3>
<ul>
  <li>encryption:&nbsp;<ul>
      <li>Create a cilium-ipsec-keys secret in the kube-system namespace for ipsec type</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">kubectl create secret -n kube-system secret generic cilium-ipsec-keys \
  --from-literal=key="3+ rfc4106(gcm(aes)) $(echo $(dd if =/dev/urandom count=20 bs=1 2&gt; /dev/null | xxd -p -c 64)) 128"</code></pre>
<blockquote>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; Enable encryption by changing the encryption.enabled to ture and type to ipsec or wiregaurd&nbsp;</p>
</blockquote>
<ul>
  <li>Encryption behavior: traffic between pods on different nodes is encrypted but traffic between pods on the same node is not encrypted</li>
</ul>
<pre><code class="language-plaintext">kubectl exec -it  cilium-pod -- cilium-dbg encrypt status</code></pre>
<ul>
  <li>The payload of the packets does not appear because it is encapsulated by ESP(encapsulating security payload) protocol&nbsp;</li>
</ul>
<h3>Mutual TLS</h3>
<ul>
  <li>Ensure the data authenticity, integrity, and confidentiality between the client and server</li>
  <li>Unlike Conventional TLS where only the server authenticates with the client, mTLS is a two way authentication between client and server</li>
  <li>Cilium depend on Spiffe framework and Spire server implementation to achieve this framework</li>
  <li>Spire is deployed as daemonset&nbsp;</li>
  <li>workflow:<ul>
      <li>eBPF programs checks if a policy requires authentication and checks the Auth table to see if this client is authenticated before</li>
      <li>If the client is not authenticated before the first packet is dropped, which triggers eBPF program to notify the cilium-agent</li>
      <li>The cilium-agent talks to the Spire agent, which in return reach out to the spire server to fetch the certificate for authentication</li>
      <li>TLS session manager in the cilium agent use these certificates to authenticate nodes for the pods &nbsp;and update the auth table.</li>
    </ul>
  </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
